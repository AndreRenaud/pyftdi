

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>i2c - I2C API &mdash; PyFtdi  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="spi - SPI API" href="spi.html" />
    <link rel="prev" title="gpio - GPIO API" href="gpio.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> PyFtdi
          

          
          </a>

          
            
            
              <div class="version">
                0.43.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../requirements.html">Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../urlscheme.html">URL Scheme</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">API documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html#release"></a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="ftdi.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ftdi</span></code> - FTDI low-level driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="gpio.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gpio</span></code> - GPIO API</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">i2c</span></code> - I<sup>2</sup>C API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#quickstart">Quickstart</a></li>
<li class="toctree-l4"><a class="reference internal" href="#classes">Classes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#exceptions">Exceptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tests">Tests</a></li>
<li class="toctree-l4"><a class="reference internal" href="#caveats">Caveats</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="spi.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">spi</span></code> - SPI API</a></li>
<li class="toctree-l3"><a class="reference internal" href="uart.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">serialext</span></code> - UART API</a></li>
<li class="toctree-l3"><a class="reference internal" href="usbtools.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">usbtools</span></code> - USB tools</a></li>
<li class="toctree-l3"><a class="reference internal" href="misc.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">misc</span></code> - Miscellaneous helpers</a></li>
<li class="toctree-l3"><a class="reference internal" href="eeprom.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">eeprom</span></code> - EEPROM API</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../pinout.html">FTDI device pinout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eeprom.html">EEPROM management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../troubleshooting.html">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../licenses.html">Licenses</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">PyFtdi</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">API documentation</a> &raquo;</li>
        
      <li><code class="xref py py-mod docutils literal notranslate"><span class="pre">i2c</span></code> - I<sup>2</sup>C API</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api/i2c.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-pyftdi.i2c">
<span id="i2c-i2c-api"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">i2c</span></code> - I<sup>2</sup>C API<a class="headerlink" href="#module-pyftdi.i2c" title="Permalink to this headline">¶</a></h1>
<div class="section" id="quickstart">
<h2>Quickstart<a class="headerlink" href="#quickstart" title="Permalink to this headline">¶</a></h2>
<p>Example: communication with an I<sup>2</sup>C GPIO expander</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Instantiate an I2C controller</span>
<span class="n">i2c</span> <span class="o">=</span> <span class="n">I2cController</span><span class="p">()</span>

<span class="c1"># Configure the first interface (IF/1) of the FTDI device as an I2C master</span>
<span class="n">i2c</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span><span class="s1">&#39;ftdi://ftdi:2232h/1&#39;</span><span class="p">)</span>

<span class="c1"># Get a port to an I2C slave device</span>
<span class="n">slave</span> <span class="o">=</span> <span class="n">i2c</span><span class="o">.</span><span class="n">get_port</span><span class="p">(</span><span class="mh">0x21</span><span class="p">)</span>

<span class="c1"># Send one byte, then receive one byte</span>
<span class="n">slave</span><span class="o">.</span><span class="n">exchange</span><span class="p">([</span><span class="mh">0x04</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Write a register to the I2C slave</span>
<span class="n">slave</span><span class="o">.</span><span class="n">write_to</span><span class="p">(</span><span class="mh">0x06</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x00</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="c1"># Read a register from the I2C slave</span>
<span class="n">slave</span><span class="o">.</span><span class="n">read_from</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Example: mastering the I<sup>2</sup>C bus with a complex transaction</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">sleep</span>

<span class="n">port</span> <span class="o">=</span> <span class="n">I2cController</span><span class="p">()</span><span class="o">.</span><span class="n">get_port</span><span class="p">(</span><span class="mh">0x56</span><span class="p">)</span>

<span class="c1"># emit a START sequence is read address, but read no data and keep the bus</span>
<span class="c1"># busy</span>
<span class="n">port</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">relax</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

<span class="c1"># wait for ~1ms</span>
<span class="n">sleep</span><span class="p">(</span><span class="mf">0.001</span><span class="p">)</span>

<span class="c1"># write 4 bytes, without neither emitting the start or stop sequence</span>
<span class="n">port</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x00\x01</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">relax</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

<span class="c1"># read 4 bytes, without emitting the start sequence, and release the bus</span>
<span class="n">port</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p>See also <a class="reference external" href="https://github.com/eblot/pyi2cflash/">pyi2cflash</a> module and <code class="docutils literal notranslate"><span class="pre">tests/i2c.py</span></code>, which provide more detailed
examples on how to use the I<sup>2</sup>C API.</p>
</div>
<div class="section" id="classes">
<h2>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyftdi.i2c.I2cPort">
<em class="property">class </em><code class="sig-prename descclassname">pyftdi.i2c.</code><code class="sig-name descname">I2cPort</code><span class="sig-paren">(</span><em class="sig-param">controller</em>, <em class="sig-param">address</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.i2c.I2cPort" title="Permalink to this definition">¶</a></dt>
<dd><p>I2C port.</p>
<p>An I2C port is never instanciated directly:
use <a class="reference internal" href="#pyftdi.i2c.I2cController.get_port" title="pyftdi.i2c.I2cController.get_port"><code class="xref py py-meth docutils literal notranslate"><span class="pre">I2cController.get_port()</span></code></a> method to obtain an I2C port.</p>
<p><code class="docutils literal notranslate"><span class="pre">relax</span></code> parameter in I2cPort methods may be used to prevent the master
from releasing the I2C bus, if some further data should be exchanged
with the slave device. Note that in case of any error, the I2C bus is
released and the <code class="docutils literal notranslate"><span class="pre">relax</span></code> parameter is ignored in such an event.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ctrl</span> <span class="o">=</span> <span class="n">I2cController</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ctrl</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span><span class="s1">&#39;ftdi://ftdi:232h/1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i2c</span> <span class="o">=</span> <span class="n">ctrl</span><span class="o">.</span><span class="n">get_port</span><span class="p">(</span><span class="mh">0x21</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># send 2 bytes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i2c</span><span class="o">.</span><span class="n">write</span><span class="p">([</span><span class="mh">0x12</span><span class="p">,</span> <span class="mh">0x34</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># send 2 bytes, then receive 2 bytes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">i2c</span><span class="o">.</span><span class="n">exchange</span><span class="p">([</span><span class="mh">0x12</span><span class="p">,</span> <span class="mh">0x34</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyftdi.i2c.I2cPort.address">
<em class="property">property </em><code class="sig-name descname">address</code><a class="headerlink" href="#pyftdi.i2c.I2cPort.address" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the slave address.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cPort.configure_register">
<code class="sig-name descname">configure_register</code><span class="sig-paren">(</span><em class="sig-param">bigendian=False</em>, <em class="sig-param">width=1</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.i2c.I2cPort.configure_register" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconfigure the format of the slave address register (if any)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bigendian</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – True for a big endian encoding, False otherwise</p></li>
<li><p><strong>width</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – width, in bytes, of the register</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cPort.exchange">
<code class="sig-name descname">exchange</code><span class="sig-paren">(</span><em class="sig-param">out=b''</em>, <em class="sig-param">readlen=0</em>, <em class="sig-param">relax=True</em>, <em class="sig-param">start=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.i2c.I2cPort.exchange" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform an exchange or a transaction with the I2c slave</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>out</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]) – an array of bytes to send to the I2c slave,
may be empty to only read out data from the slave</p></li>
<li><p><strong>readlen</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – count of bytes to read out from the slave,
may be zero to only write to the slave</p></li>
<li><p><strong>relax</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – whether to relax the bus (emit STOP) or not</p></li>
<li><p><strong>start</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – whether to emit a start sequence (w/ address)</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>data read out from the slave</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cPort.flush">
<code class="sig-name descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.i2c.I2cPort.flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Force the flush of the HW FIFOs.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cPort.frequency">
<em class="property">property </em><code class="sig-name descname">frequency</code><a class="headerlink" href="#pyftdi.i2c.I2cPort.frequency" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide the current I2c bus frequency.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cPort.poll">
<code class="sig-name descname">poll</code><span class="sig-paren">(</span><em class="sig-param">write=False</em>, <em class="sig-param">relax=True</em>, <em class="sig-param">start=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.i2c.I2cPort.poll" title="Permalink to this definition">¶</a></dt>
<dd><p>Poll a remote slave, expect ACK or NACK.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>write</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – poll in write mode (vs. read)</p></li>
<li><p><strong>relax</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – whether to relax the bus (emit STOP) or not</p></li>
<li><p><strong>start</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – whether to emit a start sequence (w/ address)</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>True if the slave acknowledged, False otherwise</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cPort.poll_cond">
<code class="sig-name descname">poll_cond</code><span class="sig-paren">(</span><em class="sig-param">width</em>, <em class="sig-param">mask</em>, <em class="sig-param">value</em>, <em class="sig-param">count</em>, <em class="sig-param">relax=True</em>, <em class="sig-param">start=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.i2c.I2cPort.poll_cond" title="Permalink to this definition">¶</a></dt>
<dd><p>Poll a remove slave, watching for condition to satisfy.
On each poll cycle, a repeated start condition is emitted, without
releasing the I2C bus, and an ACK is returned to the slave.</p>
<p>If relax is set, this method releases the I2C bus however it leaves.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>width</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – count of bytes to poll for the condition check,
that is the size of the condition register</p></li>
<li><p><strong>mask</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – binary mask to apply on the condition register
before testing for the value</p></li>
<li><p><strong>value</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – value to test the masked condition register
against. Condition is satisfied when register &amp; mask == value</p></li>
<li><p><strong>count</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – maximum poll count before raising a timeout</p></li>
<li><p><strong>relax</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – whether to relax the bus (emit STOP) or not</p></li>
<li><p><strong>start</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – whether to emit a start sequence (w/ address)</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the polled register value</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference internal" href="#pyftdi.i2c.I2cTimeoutError" title="pyftdi.i2c.I2cTimeoutError"><strong>I2cTimeoutError</strong></a> – if poll condition is not satisified</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cPort.read">
<code class="sig-name descname">read</code><span class="sig-paren">(</span><em class="sig-param">readlen=0</em>, <em class="sig-param">relax=True</em>, <em class="sig-param">start=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.i2c.I2cPort.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read one or more bytes from a remote slave</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>readlen</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – count of bytes to read out.</p></li>
<li><p><strong>relax</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – whether to relax the bus (emit STOP) or not</p></li>
<li><p><strong>start</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – whether to emit a start sequence (w/ address)</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>byte sequence of read out bytes</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference internal" href="#pyftdi.i2c.I2cIOError" title="pyftdi.i2c.I2cIOError"><strong>I2cIOError</strong></a> – if device is not configured or input parameters
are invalid</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cPort.read_from">
<code class="sig-name descname">read_from</code><span class="sig-paren">(</span><em class="sig-param">regaddr</em>, <em class="sig-param">readlen=0</em>, <em class="sig-param">relax=True</em>, <em class="sig-param">start=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.i2c.I2cPort.read_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Read one or more bytes from a remote slave</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>regaddr</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – slave register address to read from</p></li>
<li><p><strong>readlen</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – count of bytes to read out.</p></li>
<li><p><strong>relax</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – whether to relax the bus (emit STOP) or not</p></li>
<li><p><strong>start</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – whether to emit a start sequence (w/ address)</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>data read out from the slave</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference internal" href="#pyftdi.i2c.I2cIOError" title="pyftdi.i2c.I2cIOError"><strong>I2cIOError</strong></a> – if device is not configured or input parameters
are invalid</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cPort.shift_address">
<code class="sig-name descname">shift_address</code><span class="sig-paren">(</span><em class="sig-param">offset</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.i2c.I2cPort.shift_address" title="Permalink to this definition">¶</a></dt>
<dd><p>Tweak the I2C slave address, as required with some devices</p>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cPort.write">
<code class="sig-name descname">write</code><span class="sig-paren">(</span><em class="sig-param">out</em>, <em class="sig-param">relax=True</em>, <em class="sig-param">start=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.i2c.I2cPort.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write one or more bytes to a remote slave</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>out</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]) – the byte buffer to send</p></li>
<li><p><strong>relax</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – whether to relax the bus (emit STOP) or not</p></li>
<li><p><strong>start</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – whether to emit a start sequence (w/ address)</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference internal" href="#pyftdi.i2c.I2cIOError" title="pyftdi.i2c.I2cIOError"><strong>I2cIOError</strong></a> – if device is not configured or input parameters
are invalid</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cPort.write_to">
<code class="sig-name descname">write_to</code><span class="sig-paren">(</span><em class="sig-param">regaddr</em>, <em class="sig-param">out</em>, <em class="sig-param">relax=True</em>, <em class="sig-param">start=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.i2c.I2cPort.write_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Read one or more bytes from a remote slave</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>regaddr</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – slave register address to write to</p></li>
<li><p><strong>out</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]) – the byte buffer to send</p></li>
<li><p><strong>relax</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – whether to relax the bus (emit STOP) or not</p></li>
<li><p><strong>start</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – whether to emit a start sequence (w/ address)</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference internal" href="#pyftdi.i2c.I2cIOError" title="pyftdi.i2c.I2cIOError"><strong>I2cIOError</strong></a> – if device is not configured or input parameters
are invalid</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyftdi.i2c.I2cGpioPort">
<em class="property">class </em><code class="sig-prename descclassname">pyftdi.i2c.</code><code class="sig-name descname">I2cGpioPort</code><span class="sig-paren">(</span><em class="sig-param">controller</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.i2c.I2cGpioPort" title="Permalink to this definition">¶</a></dt>
<dd><p>GPIO port</p>
<p>A I2cGpioPort instance enables to drive GPIOs wich are not reserved for
I2c feature as regular GPIOs.</p>
<p>GPIO are managed as a bitfield. The LSBs are reserved for the I2c
feature, which means that the lowest pin that can be used as a GPIO is
<em>b3</em>:</p>
<ul class="simple">
<li><p><em>b0</em>: I2C SCL</p></li>
<li><p><em>b1</em>: I2C SDA_O</p></li>
<li><p><em>b2</em>: I2C SDA_I</p></li>
<li><p><em>b3</em>: first GPIO</p></li>
<li><p><em>b7</em>: reserved for I2C clock stretching, if this mode is enabled</p></li>
</ul>
<p>There is no offset bias in GPIO bit position, <em>i.e.</em> the first available
GPIO can be reached from as <code class="docutils literal notranslate"><span class="pre">0x08</span></code>.</p>
<p>Bitfield size depends on the FTDI device: 4432H series use 8-bit GPIO
ports, while 232H and 2232H series use wide 16-bit ports.</p>
<p>An I2cGpio port is never instanciated directly: use
<a class="reference internal" href="#pyftdi.i2c.I2cController.get_gpio" title="pyftdi.i2c.I2cController.get_gpio"><code class="xref py py-meth docutils literal notranslate"><span class="pre">I2cController.get_gpio()</span></code></a> method to obtain the GPIO port.</p>
<dl class="method">
<dt id="pyftdi.i2c.I2cGpioPort.all_pins">
<em class="property">property </em><code class="sig-name descname">all_pins</code><a class="headerlink" href="#pyftdi.i2c.I2cGpioPort.all_pins" title="Permalink to this definition">¶</a></dt>
<dd><p>Report the addressable GPIOs as a bitfield.</p>
<p>A true bit represents a pin which may be used as a GPIO, a false bit
a reserved pin (for I2C support)</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the bitfield of configurable GPIO pins.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cGpioPort.direction">
<em class="property">property </em><code class="sig-name descname">direction</code><a class="headerlink" href="#pyftdi.i2c.I2cGpioPort.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide the FTDI GPIO direction.self</p>
<p>A true bit represents an output GPIO, a false bit an input GPIO.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the bitfield of direction.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cGpioPort.pins">
<em class="property">property </em><code class="sig-name descname">pins</code><a class="headerlink" href="#pyftdi.i2c.I2cGpioPort.pins" title="Permalink to this definition">¶</a></dt>
<dd><p>Report the configured GPIOs as a bitfield.</p>
<p>A true bit represents a GPIO, a false bit a reserved or not
configured pin.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the bitfield of configured GPIO pins.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cGpioPort.read">
<code class="sig-name descname">read</code><span class="sig-paren">(</span><em class="sig-param">with_output=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.i2c.I2cGpioPort.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read GPIO port.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>with_output</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – set to unmask output pins</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the GPIO port pins as a bitfield</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cGpioPort.set_direction">
<code class="sig-name descname">set_direction</code><span class="sig-paren">(</span><em class="sig-param">pins</em>, <em class="sig-param">direction</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.i2c.I2cGpioPort.set_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the direction of the GPIO pins.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pins</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – which GPIO pins should be reconfigured</p></li>
<li><p><strong>direction</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – direction bitfield (high level for output)</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cGpioPort.width">
<em class="property">property </em><code class="sig-name descname">width</code><a class="headerlink" href="#pyftdi.i2c.I2cGpioPort.width" title="Permalink to this definition">¶</a></dt>
<dd><p>Report the FTDI count of addressable pins.</p>
<p>Note that all pins, including reserved I2C ones, are reported.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the count of IO pins (including I2C ones).</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cGpioPort.write">
<code class="sig-name descname">write</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.i2c.I2cGpioPort.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write GPIO port.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>value</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – the GPIO port pins as a bitfield</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyftdi.i2c.I2cController">
<em class="property">class </em><code class="sig-prename descclassname">pyftdi.i2c.</code><code class="sig-name descname">I2cController</code><a class="headerlink" href="#pyftdi.i2c.I2cController" title="Permalink to this definition">¶</a></dt>
<dd><p>I2c master.</p>
<p>An I2c master should be instanciated only once for each FTDI port that
supports MPSSE (one or two ports, depending on the FTDI device).</p>
<p>Once configured, <a class="reference internal" href="#pyftdi.i2c.I2cController.get_port" title="pyftdi.i2c.I2cController.get_port"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_port()</span></code></a> should be invoked to obtain an I2c
port for each I2c slave to drive. I2c port should handle all I/O requests
for its associated HW slave.</p>
<p>It is not recommended to use I2cController <a class="reference internal" href="#pyftdi.i2c.I2cController.read" title="pyftdi.i2c.I2cController.read"><code class="xref py py-func docutils literal notranslate"><span class="pre">read()</span></code></a>,
<a class="reference internal" href="#pyftdi.i2c.I2cController.write" title="pyftdi.i2c.I2cController.write"><code class="xref py py-func docutils literal notranslate"><span class="pre">write()</span></code></a> or <a class="reference internal" href="#pyftdi.i2c.I2cController.exchange" title="pyftdi.i2c.I2cController.exchange"><code class="xref py py-func docutils literal notranslate"><span class="pre">exchange()</span></code></a> directly.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">SCK</span></code> should be connected to <code class="docutils literal notranslate"><span class="pre">A*BUS0</span></code>, and <code class="docutils literal notranslate"><span class="pre">A*BUS7</span></code> if clock
stretching mode is enabled</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SDA</span></code> should be connected to <code class="docutils literal notranslate"><span class="pre">A*BUS1</span></code> <strong>and</strong> <code class="docutils literal notranslate"><span class="pre">A*BUS2</span></code></p></li>
</ul>
<dl class="method">
<dt id="pyftdi.i2c.I2cController.configure">
<code class="sig-name descname">configure</code><span class="sig-paren">(</span><em class="sig-param">url</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.i2c.I2cController.configure" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure the FTDI interface as a I2c master.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>url</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Device</span></code>]) – FTDI URL string, such as <code class="docutils literal notranslate"><span class="pre">ftdi://ftdi:232h/1</span></code></p></li>
<li><p><strong>kwargs</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Mapping</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code>]) – options to configure the I2C bus</p></li>
</ul>
</dd>
</dl>
<p>Accepted options:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">interface</span></code>: when URL is specifed as a USB device, the interface
named argument can be used to select a specific port of the FTDI
device, as an integer starting from 1.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">direction</span></code> a bitfield specifying the FTDI GPIO direction,
where high level defines an output, and low level defines an
input. Only useful to setup default IOs at start up, use
<a class="reference internal" href="#pyftdi.i2c.I2cGpioPort" title="pyftdi.i2c.I2cGpioPort"><code class="xref py py-class docutils literal notranslate"><span class="pre">I2cGpioPort</span></code></a> to drive GPIOs. Note that pins reserved
for I2C feature take precedence over any this setting.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial</span></code> a bitfield specifying the initial output value. Only
useful to setup default IOs at start up, use
<a class="reference internal" href="#pyftdi.i2c.I2cGpioPort" title="pyftdi.i2c.I2cGpioPort"><code class="xref py py-class docutils literal notranslate"><span class="pre">I2cGpioPort</span></code></a> to drive GPIOs.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">frequency</span></code> float value the I2C bus frequency in Hz</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">clockstretching</span></code> boolean value to enable clockstreching.
xD7 (GPIO7) pin should be connected back to xD0 (SCK)</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cController.configured">
<em class="property">property </em><code class="sig-name descname">configured</code><a class="headerlink" href="#pyftdi.i2c.I2cController.configured" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether the device has been properly configured.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if configured</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cController.direction">
<em class="property">property </em><code class="sig-name descname">direction</code><a class="headerlink" href="#pyftdi.i2c.I2cController.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide the FTDI pin direction</p>
<p>A true bit represents an output pin, a false bit an input pin.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the bitfield of direction.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cController.exchange">
<code class="sig-name descname">exchange</code><span class="sig-paren">(</span><em class="sig-param">address</em>, <em class="sig-param">out</em>, <em class="sig-param">readlen=0</em>, <em class="sig-param">relax=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.i2c.I2cController.exchange" title="Permalink to this definition">¶</a></dt>
<dd><p>Send a byte sequence to a remote slave followed with
a read request of one or more bytes.</p>
<p>This command is useful to tell the slave what data
should be read out.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>address</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – the address on the I2C bus, or None to discard start</p></li>
<li><p><strong>out</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]) – the byte buffer to send</p></li>
<li><p><strong>readlen</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – count of bytes to read out.</p></li>
<li><p><strong>relax</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – whether to relax the bus (emit STOP) or not</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>read bytes</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference internal" href="#pyftdi.i2c.I2cIOError" title="pyftdi.i2c.I2cIOError"><strong>I2cIOError</strong></a> – if device is not configured or input parameters
are invalid</p>
</dd>
</dl>
<p>Address is a logical slave address (0x7f max)</p>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cController.flush">
<code class="sig-name descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.i2c.I2cController.flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Flush the HW FIFOs.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cController.frequency">
<em class="property">property </em><code class="sig-name descname">frequency</code><a class="headerlink" href="#pyftdi.i2c.I2cController.frequency" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides the current I2C clock frequency in Hz.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the I2C bus clock frequency</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cController.frequency_max">
<em class="property">property </em><code class="sig-name descname">frequency_max</code><a class="headerlink" href="#pyftdi.i2c.I2cController.frequency_max" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides the maximum I2C clock frequency in Hz.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>I2C bus clock frequency</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cController.get_gpio">
<code class="sig-name descname">get_gpio</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.i2c.I2cController.get_gpio" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the GPIO port.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyftdi.i2c.I2cGpioPort" title="pyftdi.i2c.I2cGpioPort"><code class="xref py py-class docutils literal notranslate"><span class="pre">I2cGpioPort</span></code></a></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>GPIO port</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cController.get_port">
<code class="sig-name descname">get_port</code><span class="sig-paren">(</span><em class="sig-param">address</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.i2c.I2cController.get_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain an I2cPort to drive an I2c slave.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>address</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – the address on the I2C bus</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#pyftdi.i2c.I2cPort" title="pyftdi.i2c.I2cPort"><code class="xref py py-class docutils literal notranslate"><span class="pre">I2cPort</span></code></a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an I2cPort instance</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cController.gpio_all_pins">
<em class="property">property </em><code class="sig-name descname">gpio_all_pins</code><a class="headerlink" href="#pyftdi.i2c.I2cController.gpio_all_pins" title="Permalink to this definition">¶</a></dt>
<dd><p>Report the addressable GPIOs as a bitfield.</p>
<p>A true bit represents a pin which may be used as a GPIO, a false bit
a reserved pin (for I2C support)</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the bitfield of configurable GPIO pins.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cController.gpio_pins">
<em class="property">property </em><code class="sig-name descname">gpio_pins</code><a class="headerlink" href="#pyftdi.i2c.I2cController.gpio_pins" title="Permalink to this definition">¶</a></dt>
<dd><p>Report the configured GPIOs as a bitfield.</p>
<p>A true bit represents a GPIO, a false bit a reserved or not
configured pin.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the bitfield of configured GPIO pins.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cController.poll">
<code class="sig-name descname">poll</code><span class="sig-paren">(</span><em class="sig-param">address</em>, <em class="sig-param">write=False</em>, <em class="sig-param">relax=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.i2c.I2cController.poll" title="Permalink to this definition">¶</a></dt>
<dd><p>Poll a remote slave, expect ACK or NACK.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>address</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – the address on the I2C bus, or None to discard start</p></li>
<li><p><strong>write</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – poll in write mode (vs. read)</p></li>
<li><p><strong>relax</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – whether to relax the bus (emit STOP) or not</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>True if the slave acknowledged, False otherwise</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cController.poll_cond">
<code class="sig-name descname">poll_cond</code><span class="sig-paren">(</span><em class="sig-param">address</em>, <em class="sig-param">fmt</em>, <em class="sig-param">mask</em>, <em class="sig-param">value</em>, <em class="sig-param">count</em>, <em class="sig-param">relax=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.i2c.I2cController.poll_cond" title="Permalink to this definition">¶</a></dt>
<dd><p>Poll a remove slave, watching for condition to satisfy.
On each poll cycle, a repeated start condition is emitted, without
releasing the I2C bus, and an ACK is returned to the slave.</p>
<p>If relax is set, this method releases the I2C bus however it leaves.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>address</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – the address on the I2C bus, or None to discard start</p></li>
<li><p><strong>fmt</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – struct format for poll register</p></li>
<li><p><strong>mask</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – binary mask to apply on the condition register
before testing for the value</p></li>
<li><p><strong>value</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – value to test the masked condition register
against. Condition is satisfied when register &amp; mask == value</p></li>
<li><p><strong>count</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – maximum poll count before raising a timeout</p></li>
<li><p><strong>relax</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – whether to relax the bus (emit STOP) or not</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the polled register value, or None if poll failed</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cController.read">
<code class="sig-name descname">read</code><span class="sig-paren">(</span><em class="sig-param">address</em>, <em class="sig-param">readlen=1</em>, <em class="sig-param">relax=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.i2c.I2cController.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read one or more bytes from a remote slave</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>address</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – the address on the I2C bus, or None to discard start</p></li>
<li><p><strong>readlen</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – count of bytes to read out.</p></li>
<li><p><strong>relax</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – not used</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>read bytes</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference internal" href="#pyftdi.i2c.I2cIOError" title="pyftdi.i2c.I2cIOError"><strong>I2cIOError</strong></a> – if device is not configured or input parameters
are invalid</p>
</dd>
</dl>
<p>Address is a logical slave address (0x7f max)</p>
<p>Most I2C devices require a register address to read out
check out the exchange() method.</p>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cController.read_gpio">
<code class="sig-name descname">read_gpio</code><span class="sig-paren">(</span><em class="sig-param">with_output=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.i2c.I2cController.read_gpio" title="Permalink to this definition">¶</a></dt>
<dd><p>Read GPIO port.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>with_output</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – set to unmask output pins</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the GPIO port pins as a bitfield</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cController.set_gpio_direction">
<code class="sig-name descname">set_gpio_direction</code><span class="sig-paren">(</span><em class="sig-param">pins</em>, <em class="sig-param">direction</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.i2c.I2cController.set_gpio_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the direction of the GPIO pins.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pins</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – which GPIO pins should be reconfigured</p></li>
<li><p><strong>direction</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – direction bitfield (on for output)</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cController.set_retry_count">
<code class="sig-name descname">set_retry_count</code><span class="sig-paren">(</span><em class="sig-param">count</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.i2c.I2cController.set_retry_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the default retry count when a communication error occurs,
before bailing out.
:type count: <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>
:param count: count of retries</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cController.terminate">
<code class="sig-name descname">terminate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.i2c.I2cController.terminate" title="Permalink to this definition">¶</a></dt>
<dd><p>Close the FTDI interface.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cController.validate_address">
<em class="property">classmethod </em><code class="sig-name descname">validate_address</code><span class="sig-paren">(</span><em class="sig-param">address</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.i2c.I2cController.validate_address" title="Permalink to this definition">¶</a></dt>
<dd><p>Assert an I2C slave address is in the supported range.
None is a special bypass address.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>address</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – the address on the I2C bus</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference internal" href="#pyftdi.i2c.I2cIOError" title="pyftdi.i2c.I2cIOError"><strong>I2cIOError</strong></a> – if the I2C slave address is not supported</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cController.width">
<em class="property">property </em><code class="sig-name descname">width</code><a class="headerlink" href="#pyftdi.i2c.I2cController.width" title="Permalink to this definition">¶</a></dt>
<dd><p>Report the FTDI count of addressable pins.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the count of IO pins (including I2C ones).</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cController.write">
<code class="sig-name descname">write</code><span class="sig-paren">(</span><em class="sig-param">address</em>, <em class="sig-param">out</em>, <em class="sig-param">relax=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.i2c.I2cController.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write one or more bytes to a remote slave</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>address</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – the address on the I2C bus, or None to discard start</p></li>
<li><p><strong>out</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]) – the byte buffer to send</p></li>
<li><p><strong>relax</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – whether to relax the bus (emit STOP) or not</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference internal" href="#pyftdi.i2c.I2cIOError" title="pyftdi.i2c.I2cIOError"><strong>I2cIOError</strong></a> – if device is not configured or input parameters
are invalid</p>
</dd>
</dl>
<p>Address is a logical slave address (0x7f max)</p>
<p>Most I2C devices require a register address to write into. It should
be added as the first (byte)s of the output buffer.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.i2c.I2cController.write_gpio">
<code class="sig-name descname">write_gpio</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.i2c.I2cController.write_gpio" title="Permalink to this definition">¶</a></dt>
<dd><p>Write GPIO port.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>value</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – the GPIO port pins as a bitfield</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="exceptions">
<h2>Exceptions<a class="headerlink" href="#exceptions" title="Permalink to this headline">¶</a></h2>
<dl class="exception">
<dt id="pyftdi.i2c.I2cIOError">
<em class="property">exception </em><code class="sig-prename descclassname">pyftdi.i2c.</code><code class="sig-name descname">I2cIOError</code><a class="headerlink" href="#pyftdi.i2c.I2cIOError" title="Permalink to this definition">¶</a></dt>
<dd><p>I2c I/O error</p>
</dd></dl>

<dl class="exception">
<dt id="pyftdi.i2c.I2cNackError">
<em class="property">exception </em><code class="sig-prename descclassname">pyftdi.i2c.</code><code class="sig-name descname">I2cNackError</code><a class="headerlink" href="#pyftdi.i2c.I2cNackError" title="Permalink to this definition">¶</a></dt>
<dd><p>I2c NACK receive from slave</p>
</dd></dl>

<dl class="exception">
<dt id="pyftdi.i2c.I2cTimeoutError">
<em class="property">exception </em><code class="sig-prename descclassname">pyftdi.i2c.</code><code class="sig-name descname">I2cTimeoutError</code><a class="headerlink" href="#pyftdi.i2c.I2cTimeoutError" title="Permalink to this definition">¶</a></dt>
<dd><p>I2c timeout on polling</p>
</dd></dl>

</div>
<div class="section" id="tests">
<h2>Tests<a class="headerlink" href="#tests" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt>I<sup>2</sup>C sample tests expect:</dt><dd><ul class="simple">
<li><p>TCA9555 device on slave address 0x21</p></li>
<li><p>ADXL345 device on slave address 0x53</p></li>
</ul>
</dd>
</dl>
<p>Checkout a fresh copy from <a class="reference external" href="https://www.github.com/eblot/pyftdi">PyFtdi</a> github repository.</p>
<p>See <a class="reference internal" href="../pinout.html"><span class="doc">FTDI device pinout</span></a> for FTDI wiring.</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># optional: specify an alternative FTDI device</span>
<span class="nb">export</span> <span class="nv">FTDI_DEVICE</span><span class="o">=</span>ftdi://ftdi:2232h/1
<span class="c1"># optional: increase log level</span>
<span class="nb">export</span> <span class="nv">FTDI_LOGLEVEL</span><span class="o">=</span>DEBUG
<span class="c1"># be sure to connect the appropriate I2C slaves to the FTDI I2C bus and run</span>
<span class="nv">PYTHONPATH</span><span class="o">=</span>. python3 pyftdi/tests/i2c.py
</pre></div>
</div>
</div>
<div class="section" id="caveats">
<h2>Caveats<a class="headerlink" href="#caveats" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Due to the FTDI MPSSE engine limitations, the actual bitrate over I2C is very
slow. As the I2C protocol enforces that each I2C exchanged byte needs to be
acknowledged by the peer, a I2C byte cannot be written to the slave before
the previous byte has been acknowledged by the slave and read back by the
I2C master, that is the host. This requires several USB transfer for each
byte, on top of each latency of the USB stack may add up. <a class="reference external" href="https://www.github.com/eblot/pyftdi">PyFtdi</a> is
therefore not recommended if you need to achieve medium to high speed
communication with a slave (relative to the I2C clock…), nor than FTDI
devices are for this kind of usage.</p></li>
</ul>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="spi.html" class="btn btn-neutral float-right" title="spi - SPI API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="gpio.html" class="btn btn-neutral float-left" title="gpio - GPIO API" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2010-2020, Emmanuel Blot &lt;emmanuel.blot@free.fr&gt;

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>