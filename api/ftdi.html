

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ftdi - FTDI low-level driver &mdash; PyFtdi  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="gpio - GPIO API" href="gpio.html" />
    <link rel="prev" title="API documentation" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> PyFtdi
          

          
          </a>

          
            
            
              <div class="version">
                0.43.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../requirements.html">Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../urlscheme.html">URL Scheme</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">API documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html#release"></a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ftdi</span></code> - FTDI low-level driver</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#classes">Classes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#exceptions">Exceptions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="gpio.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gpio</span></code> - GPIO API</a></li>
<li class="toctree-l3"><a class="reference internal" href="i2c.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">i2c</span></code> - I<sup>2</sup>C API</a></li>
<li class="toctree-l3"><a class="reference internal" href="spi.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">spi</span></code> - SPI API</a></li>
<li class="toctree-l3"><a class="reference internal" href="uart.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">serialext</span></code> - UART API</a></li>
<li class="toctree-l3"><a class="reference internal" href="usbtools.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">usbtools</span></code> - USB tools</a></li>
<li class="toctree-l3"><a class="reference internal" href="misc.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">misc</span></code> - Miscellaneous helpers</a></li>
<li class="toctree-l3"><a class="reference internal" href="eeprom.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">eeprom</span></code> - EEPROM API</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../pinout.html">FTDI device pinout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eeprom.html">EEPROM management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../troubleshooting.html">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../licenses.html">Licenses</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">PyFtdi</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">API documentation</a> &raquo;</li>
        
      <li><code class="xref py py-mod docutils literal notranslate"><span class="pre">ftdi</span></code> - FTDI low-level driver</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api/ftdi.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-pyftdi.ftdi">
<span id="ftdi-ftdi-low-level-driver"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">ftdi</span></code> - FTDI low-level driver<a class="headerlink" href="#module-pyftdi.ftdi" title="Permalink to this headline">¶</a></h1>
<p>This module implements access to the low level FTDI hardware. There are very
few reasons to use this module directly. Most of <a class="reference external" href="https://www.github.com/eblot/pyftdi">PyFtdi</a> features are available
through the dedicated <a class="reference internal" href="index.html"><span class="doc">APIs</span></a>.</p>
<div class="section" id="classes">
<h2>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyftdi.ftdi.Ftdi">
<em class="property">class </em><code class="sig-prename descclassname">pyftdi.ftdi.</code><code class="sig-name descname">Ftdi</code><a class="headerlink" href="#pyftdi.ftdi.Ftdi" title="Permalink to this definition">¶</a></dt>
<dd><p>FTDI device driver</p>
<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.add_custom_product">
<em class="property">classmethod </em><code class="sig-name descname">add_custom_product</code><span class="sig-paren">(</span><em class="sig-param">vid</em>, <em class="sig-param">pid</em>, <em class="sig-param">pidname=''</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.add_custom_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a custom USB product identifier.</p>
<p>It is required for opening FTDI device with non-standard VID/PID
USB identifiers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vid</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Vendor ID (USB 16-bit identifier)</p></li>
<li><p><strong>pid</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Product ID (USB 16-bit identifier)</p></li>
<li><p><strong>pidname</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – Product name (arbitrary string)</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if the product id is already referenced</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.add_custom_vendor">
<em class="property">classmethod </em><code class="sig-name descname">add_custom_vendor</code><span class="sig-paren">(</span><em class="sig-param">vid</em>, <em class="sig-param">vidname=''</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.add_custom_vendor" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a custom USB vendor identifier.</p>
<p>It can be useful to use a pretty URL for opening FTDI device</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vid</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Vendor ID (USB 16-bit identifier)</p></li>
<li><p><strong>vidname</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – Vendor name (arbitrary string)</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if the vendor id is already referenced</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.bitbang_enabled">
<em class="property">property </em><code class="sig-name descname">bitbang_enabled</code><a class="headerlink" href="#pyftdi.ftdi.Ftdi.bitbang_enabled" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell whether some bitbang mode is activated</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if the FTDI interface is configured to support
bitbanging</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.calc_eeprom_checksum">
<code class="sig-name descname">calc_eeprom_checksum</code><span class="sig-paren">(</span><em class="sig-param">data</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.calc_eeprom_checksum" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate EEPROM checksum over the data</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code>]) – data to compute checksum over. Must be an even number
of bytes</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>checksum</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.close">
<code class="sig-name descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close the FTDI interface/port.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.create_from_url">
<em class="property">classmethod </em><code class="sig-name descname">create_from_url</code><span class="sig-paren">(</span><em class="sig-param">url</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.create_from_url" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an Ftdi instance from an URL</p>
<p>URL scheme: ftdi://[vendor[:product[:index|:serial]]]/interface</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>url</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – FTDI device selector</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#pyftdi.ftdi.Ftdi" title="pyftdi.ftdi.Ftdi"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ftdi</span></code></a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a fresh, open Ftdi instance</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.decode_modem_status">
<em class="property">classmethod </em><code class="sig-name descname">decode_modem_status</code><span class="sig-paren">(</span><em class="sig-param">value</em>, <em class="sig-param">error_only=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.decode_modem_status" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode the FTDI modem status bitfield into short strings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>) – 2-byte mode status</p></li>
<li><p><strong>error_only</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – only decode error flags</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a tuple of status identifiers</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.device_version">
<em class="property">property </em><code class="sig-name descname">device_version</code><a class="headerlink" href="#pyftdi.ftdi.Ftdi.device_version" title="Permalink to this definition">¶</a></dt>
<dd><p>Report the device version, i.e. the kind of device.</p>
<dl class="field-list simple">
<dt class="field-odd">See</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyftdi.ftdi.Ftdi.ic_name" title="pyftdi.ftdi.Ftdi.ic_name"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ic_name()</span></code></a> for a product version of this information.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the device version (16-bit integer)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.enable_3phase_clock">
<code class="sig-name descname">enable_3phase_clock</code><span class="sig-paren">(</span><em class="sig-param">enable=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.enable_3phase_clock" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable 3-phase clocking mode, useful in MPSSE mode.</p>
<p>3-phase clock is mostly useful with I2C mode. It is also be used
as a workaround to support SPI mode 3.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>enable</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – whether to enable or disable this mode.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference internal" href="#pyftdi.ftdi.FtdiMpsseError" title="pyftdi.ftdi.FtdiMpsseError"><strong>FtdiMpsseError</strong></a> – if MPSSE mode is not enabled or device is
not capable of 3-phase clocking</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.enable_adaptive_clock">
<code class="sig-name descname">enable_adaptive_clock</code><span class="sig-paren">(</span><em class="sig-param">enable=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.enable_adaptive_clock" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable adaptative clock mode, useful in MPSEE mode.</p>
<p>Adaptive clock is a unique feature designed for a feedback clock
for JTAG with ARM core.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>enable</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – whether to enable or disable this mode.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference internal" href="#pyftdi.ftdi.FtdiMpsseError" title="pyftdi.ftdi.FtdiMpsseError"><strong>FtdiMpsseError</strong></a> – if MPSSE mode is not enabled</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.enable_drivezero_mode">
<code class="sig-name descname">enable_drivezero_mode</code><span class="sig-paren">(</span><em class="sig-param">lines</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.enable_drivezero_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable drive-zero mode, useful in MPSSE mode.</p>
<p>drive-zero mode is mostly useful with I2C mode, to support the open
collector driving mode.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>lines</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – bitfield of GPIO to drive in collector driven mode</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference internal" href="#pyftdi.ftdi.FtdiMpsseError" title="pyftdi.ftdi.FtdiMpsseError"><strong>FtdiMpsseError</strong></a> – if MPSSE mode is not enabled or device is
not capable of drive-zero mode</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.enable_loopback_mode">
<code class="sig-name descname">enable_loopback_mode</code><span class="sig-paren">(</span><em class="sig-param">loopback=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.enable_loopback_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable loopback, i.e. connect DO to DI in FTDI MPSSE port for test
purposes only. It does not support UART (TX to RX) mode.</p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">param loopback</dt>
<dd class="field-odd"><p>whether to enable or disable this mode</p>
</dd>
</dl>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.fifo_sizes">
<em class="property">property </em><code class="sig-name descname">fifo_sizes</code><a class="headerlink" href="#pyftdi.ftdi.Ftdi.fifo_sizes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the (TX, RX) tupple of hardware FIFO sizes</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>2-tuple of TX, RX FIFO size in bytes</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.find_all">
<em class="property">static </em><code class="sig-name descname">find_all</code><span class="sig-paren">(</span><em class="sig-param">vps</em>, <em class="sig-param">nocache=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.find_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all devices that match the vendor/product pairs of the vps
list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vps</strong> (<em>tuple</em><em>(</em><em>int</em><em>, </em><em>int</em><em>)</em>) – a sequence of 2-tuple (vid, pid) pairs</p></li>
<li><p><strong>nocache</strong> (<em>bool</em>) – bypass cache to re-enumerate USB devices on
the host</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a list of 5-tuple (vid, pid, sernum, iface, description)
device descriptors</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list(tuple(int,int,str,int,str))</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.frequency_max">
<em class="property">property </em><code class="sig-name descname">frequency_max</code><a class="headerlink" href="#pyftdi.ftdi.Ftdi.frequency_max" title="Permalink to this definition">¶</a></dt>
<dd><p>Tells the maximum frequency for MPSSE clock.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the maximum supported frequency in Hz</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.get_cd">
<code class="sig-name descname">get_cd</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.get_cd" title="Permalink to this definition">¶</a></dt>
<dd><p>Read terminal status line: Carrier Detect</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>CD line logical level</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.get_cts">
<code class="sig-name descname">get_cts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.get_cts" title="Permalink to this definition">¶</a></dt>
<dd><p>Read terminal status line: Clear To Send</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>CTS line logical level</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.get_device">
<em class="property">classmethod </em><code class="sig-name descname">get_device</code><span class="sig-paren">(</span><em class="sig-param">url</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.get_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a USB device from its URL, without opening an instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>url</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – input URL to parse</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Device</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the USB device that match the specified URL</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.get_dsr">
<code class="sig-name descname">get_dsr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.get_dsr" title="Permalink to this definition">¶</a></dt>
<dd><p>Read terminal status line: Data Set Ready</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>DSR line logical level</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.get_error_string">
<em class="property">classmethod </em><code class="sig-name descname">get_error_string</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.get_error_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for legacy compatibility.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a constant, meaningless string</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.get_identifiers">
<em class="property">classmethod </em><code class="sig-name descname">get_identifiers</code><span class="sig-paren">(</span><em class="sig-param">url</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.get_identifiers" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the identifiers of an FTDI device from URL, if any</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>url</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – input URL to parse</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">UsbDeviceDescriptor</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.get_latency_timer">
<code class="sig-name descname">get_latency_timer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.get_latency_timer" title="Permalink to this definition">¶</a></dt>
<dd><p>Get latency timer.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the current latency (unspecified unit)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.get_ri">
<code class="sig-name descname">get_ri</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.get_ri" title="Permalink to this definition">¶</a></dt>
<dd><p>Read terminal status line: Ring Indicator</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>RI line logical level</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.has_drivezero">
<em class="property">property </em><code class="sig-name descname">has_drivezero</code><a class="headerlink" href="#pyftdi.ftdi.Ftdi.has_drivezero" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell whether the device supports drive-zero mode, i.e. if the
device supports the open-collector drive mode, useful for I2C
communication for example.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if the FTDI device features drive-zero mode</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyftdi.ftdi.FtdiError" title="pyftdi.ftdi.FtdiError"><strong>FtdiError</strong></a> – if no FTDI port is open</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.has_mpsse">
<em class="property">property </em><code class="sig-name descname">has_mpsse</code><a class="headerlink" href="#pyftdi.ftdi.Ftdi.has_mpsse" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell whether the device supports MPSSE (I2C, SPI, JTAG, …)</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if the FTDI device supports MPSSE</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyftdi.ftdi.FtdiError" title="pyftdi.ftdi.FtdiError"><strong>FtdiError</strong></a> – if no FTDI port is open</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.has_wide_port">
<em class="property">property </em><code class="sig-name descname">has_wide_port</code><a class="headerlink" href="#pyftdi.ftdi.Ftdi.has_wide_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell whether the device supports 16-bit GPIO ports (vs. 8 bits)</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if the FTDI device supports wide GPIO port</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyftdi.ftdi.FtdiError" title="pyftdi.ftdi.FtdiError"><strong>FtdiError</strong></a> – if no FTDI port is open</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.ic_name">
<em class="property">property </em><code class="sig-name descname">ic_name</code><a class="headerlink" href="#pyftdi.ftdi.Ftdi.ic_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current type of the FTDI device as a string</p>
<p>see also <a class="reference external" href="http://www.ftdichip.com/Support/">http://www.ftdichip.com/Support/</a>
Documents/TechnicalNotes/TN_100_USB_VID-PID_Guidelines.pdf</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the identified FTDI device as a string</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.is_H_series">
<em class="property">property </em><code class="sig-name descname">is_H_series</code><a class="headerlink" href="#pyftdi.ftdi.Ftdi.is_H_series" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell whether the device is a high-end FTDI</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if the FTDI device is a high-end USB-UART bridge</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyftdi.ftdi.FtdiError" title="pyftdi.ftdi.FtdiError"><strong>FtdiError</strong></a> – if no FTDI port is open</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.is_connected">
<em class="property">property </em><code class="sig-name descname">is_connected</code><a class="headerlink" href="#pyftdi.ftdi.Ftdi.is_connected" title="Permalink to this definition">¶</a></dt>
<dd><p>Tells whether this instance is connected to an actual USB slave.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the slave connection status</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.is_legacy">
<em class="property">property </em><code class="sig-name descname">is_legacy</code><a class="headerlink" href="#pyftdi.ftdi.Ftdi.is_legacy" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell whether the device is a low-end FTDI</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if the FTDI device can only be used as a slow USB-UART
bridge</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyftdi.ftdi.FtdiError" title="pyftdi.ftdi.FtdiError"><strong>FtdiError</strong></a> – if no FTDI port is open</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.is_mpsse">
<em class="property">property </em><code class="sig-name descname">is_mpsse</code><a class="headerlink" href="#pyftdi.ftdi.Ftdi.is_mpsse" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell whether the device is configured in MPSSE mode</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if the FTDI interface is configured in MPSSE mode</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.is_mpsse_interface">
<code class="sig-name descname">is_mpsse_interface</code><span class="sig-paren">(</span><em class="sig-param">interface</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.is_mpsse_interface" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell whether the interface supports MPSSE (I2C, SPI, JTAG, …)</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if the FTDI interface supports MPSSE</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyftdi.ftdi.FtdiError" title="pyftdi.ftdi.FtdiError"><strong>FtdiError</strong></a> – if no FTDI port is open</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.modem_status">
<code class="sig-name descname">modem_status</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.modem_status" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide the current modem status as a tuple of set signals</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>decodede modem status as short strings</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.mpsse_bit_delay">
<em class="property">property </em><code class="sig-name descname">mpsse_bit_delay</code><a class="headerlink" href="#pyftdi.ftdi.Ftdi.mpsse_bit_delay" title="Permalink to this definition">¶</a></dt>
<dd><p>Delay between execution of two MPSSE SET_BITS commands.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>minimum delay (actual value might be larger) in seconds</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.open">
<code class="sig-name descname">open</code><span class="sig-paren">(</span><em class="sig-param">vendor</em>, <em class="sig-param">product</em>, <em class="sig-param">bus=None</em>, <em class="sig-param">address=None</em>, <em class="sig-param">index=0</em>, <em class="sig-param">serial=None</em>, <em class="sig-param">interface=1</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.open" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a new interface to the specified FTDI device.</p>
<p>If several FTDI devices of the same kind (vid, pid) are connected
to the host, either index or serial argument should be used to
discriminate the FTDI device.</p>
<p>index argument is not a reliable solution as the host may enumerate
the USB device in random order. serial argument is more reliable
selector and should always be prefered.</p>
<p>Some FTDI devices support several interfaces/ports (such as FT2232H
and FT4232H). The interface argument selects the FTDI port to use,
starting from 1 (not 0).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vendor</strong> (<em>int</em>) – USB vendor id</p></li>
<li><p><strong>product</strong> (<em>int</em>) – USB product id</p></li>
<li><p><strong>bus</strong> (<em>int</em>) – optional selector,  USB bus</p></li>
<li><p><strong>address</strong> (<em>int</em>) – optional selector, USB address on bus</p></li>
<li><p><strong>index</strong> (<em>int</em>) – optional selector, specified the n-th matching
FTDI enumerated USB device on the host</p></li>
<li><p><strong>serial</strong> (<em>str</em>) – optional selector, specified the FTDI device
by its serial number</p></li>
<li><p><strong>interface</strong> (<em>str</em>) – FTDI interface/port</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.open_bitbang">
<code class="sig-name descname">open_bitbang</code><span class="sig-paren">(</span><em class="sig-param">vendor</em>, <em class="sig-param">product</em>, <em class="sig-param">bus=None</em>, <em class="sig-param">address=None</em>, <em class="sig-param">index=0</em>, <em class="sig-param">serial=None</em>, <em class="sig-param">interface=1</em>, <em class="sig-param">direction=0</em>, <em class="sig-param">latency=16</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.open_bitbang" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a new interface to the specified FTDI device in bitbang mode.</p>
<p>Bitbang enables direct read or write to FTDI GPIOs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vendor</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – USB vendor id</p></li>
<li><p><strong>product</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – USB product id</p></li>
<li><p><strong>index</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – optional selector, specified the n-th matching
FTDI enumerated USB device on the host</p></li>
<li><p><strong>serial</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – optional selector, specified the FTDI device
by its serial number</p></li>
<li><p><strong>interface</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – FTDI interface/port</p></li>
<li><p><strong>direction</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – a bitfield specifying the FTDI GPIO direction,
where high level defines an output, and low level defines an
input</p></li>
<li><p><strong>latency</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – low-level latency to select the USB FTDI poll
delay. The shorter the delay, the higher the host CPU load.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.open_bitbang_from_device">
<code class="sig-name descname">open_bitbang_from_device</code><span class="sig-paren">(</span><em class="sig-param">device</em>, <em class="sig-param">interface=1</em>, <em class="sig-param">direction=0</em>, <em class="sig-param">latency=16</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.open_bitbang_from_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a new interface to the specified FTDI device in bitbang mode.</p>
<p>Bitbang enables direct read or write to FTDI GPIOs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>device</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Device</span></code>) – FTDI USB device</p></li>
<li><p><strong>interface</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – FTDI interface/port</p></li>
<li><p><strong>direction</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – a bitfield specifying the FTDI GPIO direction,
where high level defines an output, and low level defines an
input</p></li>
<li><p><strong>latency</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – low-level latency to select the USB FTDI poll
delay. The shorter the delay, the higher the host CPU load.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.open_bitbang_from_url">
<code class="sig-name descname">open_bitbang_from_url</code><span class="sig-paren">(</span><em class="sig-param">url</em>, <em class="sig-param">direction=0</em>, <em class="sig-param">latency=16</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.open_bitbang_from_url" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a new interface to the specified FTDI device in bitbang mode.</p>
<p>Bitbang enables direct read or write to FTDI GPIOs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>url</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – a FTDI URL selector</p></li>
<li><p><strong>direction</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – a bitfield specifying the FTDI GPIO direction,
where high level defines an output, and low level defines an
input</p></li>
<li><p><strong>initial</strong> – ignored</p></li>
<li><p><strong>latency</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – low-level latency to select the USB FTDI poll
delay. The shorter the delay, the higher the host CPU load.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.open_from_device">
<code class="sig-name descname">open_from_device</code><span class="sig-paren">(</span><em class="sig-param">device</em>, <em class="sig-param">interface=1</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.open_from_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a new interface from an existing USB device.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>device</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Device</span></code>) – FTDI USB device (PyUSB instance)</p></li>
<li><p><strong>interface</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – FTDI interface to use (integer starting from 1)</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.open_from_url">
<code class="sig-name descname">open_from_url</code><span class="sig-paren">(</span><em class="sig-param">url</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.open_from_url" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a new interface to the specified FTDI device.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>url</strong> (<em>str</em>) – a FTDI URL selector</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.open_mpsse">
<code class="sig-name descname">open_mpsse</code><span class="sig-paren">(</span><em class="sig-param">vendor</em>, <em class="sig-param">product</em>, <em class="sig-param">bus=None</em>, <em class="sig-param">address=None</em>, <em class="sig-param">index=0</em>, <em class="sig-param">serial=None</em>, <em class="sig-param">interface=1</em>, <em class="sig-param">direction=0</em>, <em class="sig-param">initial=0</em>, <em class="sig-param">frequency=6000000.0</em>, <em class="sig-param">latency=16</em>, <em class="sig-param">debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.open_mpsse" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a new interface to the specified FTDI device in MPSSE mode.</p>
<p>MPSSE enables I2C, SPI, JTAG or other synchronous serial interface
modes (vs. UART mode).</p>
<p>If several FTDI devices of the same kind (vid, pid) are connected
to the host, either index or serial argument should be used to
discriminate the FTDI device.</p>
<p>index argument is not a reliable solution as the host may enumerate
the USB device in random order. serial argument is more reliable
selector and should always be prefered.</p>
<p>Some FTDI devices support several interfaces/ports (such as FT2232H
and FT4232H). The interface argument selects the FTDI port to use,
starting from 1 (not 0). Note that not all FTDI ports are MPSSE
capable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vendor</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – USB vendor id</p></li>
<li><p><strong>product</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – USB product id</p></li>
<li><p><strong>bus</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]) – optional selector, USB bus</p></li>
<li><p><strong>address</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]) – optional selector, USB address on bus</p></li>
<li><p><strong>index</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – optional selector, specified the n-th matching
FTDI enumerated USB device on the host</p></li>
<li><p><strong>serial</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – optional selector, specified the FTDI device
by its serial number</p></li>
<li><p><strong>interface</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – FTDI interface/port</p></li>
<li><p><strong>direction</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – a bitfield specifying the FTDI GPIO direction,
where high level defines an output, and low level defines an
input</p></li>
<li><p><strong>initial</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – a bitfield specifying the initial output value</p></li>
<li><p><strong>frequency</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – serial interface clock in Hz</p></li>
<li><p><strong>latency</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – low-level latency in milliseconds. The shorter
the delay, the higher the host CPU load. Do not use shorter
values than the default, as it triggers data loss in FTDI.</p></li>
<li><p><strong>debug</strong> (<em>bool</em>) – use a tracer to decode MPSSE protocol</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>actual bus frequency in Hz</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.open_mpsse_from_device">
<code class="sig-name descname">open_mpsse_from_device</code><span class="sig-paren">(</span><em class="sig-param">device</em>, <em class="sig-param">interface=1</em>, <em class="sig-param">direction=0</em>, <em class="sig-param">initial=0</em>, <em class="sig-param">frequency=6000000.0</em>, <em class="sig-param">latency=16</em>, <em class="sig-param">debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.open_mpsse_from_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a new interface to the specified FTDI device in MPSSE mode.</p>
<p>MPSSE enables I2C, SPI, JTAG or other synchronous serial interface
modes (vs. UART mode).</p>
<p>If several FTDI devices of the same kind (vid, pid) are connected
to the host, either index or serial argument should be used to
discriminate the FTDI device.</p>
<p>index argument is not a reliable solution as the host may enumerate
the USB device in random order. serial argument is more reliable
selector and should always be prefered.</p>
<p>Some FTDI devices support several interfaces/ports (such as FT2232H
and FT4232H). The interface argument selects the FTDI port to use,
starting from 1 (not 0). Note that not all FTDI ports are MPSSE
capable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>device</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Device</span></code>) – FTDI USB device</p></li>
<li><p><strong>interface</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – FTDI interface/port</p></li>
<li><p><strong>direction</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – a bitfield specifying the FTDI GPIO direction,
where high level defines an output, and low level defines an
input</p></li>
<li><p><strong>initial</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – a bitfield specifying the initial output value</p></li>
<li><p><strong>frequency</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – serial interface clock in Hz</p></li>
<li><p><strong>latency</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – low-level latency in milliseconds. The shorter
the delay, the higher the host CPU load. Do not use shorter
values than the default, as it triggers data loss in FTDI.</p></li>
<li><p><strong>debug</strong> (<em>bool</em>) – use a tracer to decode MPSSE protocol</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>actual bus frequency in Hz</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.open_mpsse_from_url">
<code class="sig-name descname">open_mpsse_from_url</code><span class="sig-paren">(</span><em class="sig-param">url</em>, <em class="sig-param">direction=0</em>, <em class="sig-param">initial=0</em>, <em class="sig-param">frequency=6000000.0</em>, <em class="sig-param">latency=16</em>, <em class="sig-param">debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.open_mpsse_from_url" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a new interface to the specified FTDI device in MPSSE mode.</p>
<p>MPSSE enables I2C, SPI, JTAG or other synchronous serial interface
modes (vs. UART mode).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>url</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – a FTDI URL selector</p></li>
<li><p><strong>direction</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – a bitfield specifying the FTDI GPIO direction,
where high level defines an output, and low level defines an
input</p></li>
<li><p><strong>initial</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – a bitfield specifying the initial output value</p></li>
<li><p><strong>frequency</strong> (<em>float</em>) – serial interface clock in Hz</p></li>
<li><p><strong>latency</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – low-level latency in milliseconds. The shorter
the delay, the higher the host CPU load. Do not use shorter
values than the default, as it triggers data loss in FTDI.</p></li>
<li><p><strong>debug</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – use a tracer to decode MPSSE protocol</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>actual bus frequency in Hz</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.overwrite_eeprom">
<code class="sig-name descname">overwrite_eeprom</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">dry_run=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.overwrite_eeprom" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the whole EEPROM content, from first to last byte.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>You can brick your device with invalid size or content.
Use this function at your own risk, and RTFM.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code>]) – data to be written (should include the checksum)</p></li>
<li><p><strong>dry_run</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – log what should be written, do not actually
change the EEPROM content</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.poll_modem_status">
<code class="sig-name descname">poll_modem_status</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.poll_modem_status" title="Permalink to this definition">¶</a></dt>
<dd><p>Poll modem status information.</p>
<p>This function allows the retrieve the two status bytes of the
device, useful in UART mode.</p>
<p>FTDI device does not have a so-called USB “interrupt” end-point,
event polling on the UART interface is done through the regular
control endpoint.</p>
<p>see <a class="reference internal" href="#pyftdi.ftdi.Ftdi.modem_status" title="pyftdi.ftdi.Ftdi.modem_status"><code class="xref py py-func docutils literal notranslate"><span class="pre">modem_status()</span></code></a> to obtain decoded status strings</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>modem status, as a proprietary bitfield</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.port_width">
<em class="property">property </em><code class="sig-name descname">port_width</code><a class="headerlink" href="#pyftdi.ftdi.Ftdi.port_width" title="Permalink to this definition">¶</a></dt>
<dd><p>Report the width of a single port / interface</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the width of the port, in bits</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyftdi.ftdi.FtdiError" title="pyftdi.ftdi.FtdiError"><strong>FtdiError</strong></a> – if no FTDI port is open</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.purge_buffers">
<code class="sig-name descname">purge_buffers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.purge_buffers" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the buffers on the chip and the internal read buffer.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.purge_rx_buffer">
<code class="sig-name descname">purge_rx_buffer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.purge_rx_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the read buffer on the chip and the internal read buffer.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.purge_tx_buffer">
<code class="sig-name descname">purge_tx_buffer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.purge_tx_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the write buffer on the chip.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.read_data">
<code class="sig-name descname">read_data</code><span class="sig-paren">(</span><em class="sig-param">size</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.read_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Shortcut to received a bytes buffer instead of the array of bytes.</p>
<p>Note that output byte buffer may be shorted than the requested
size.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>size</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – the number of bytes to received from the device</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>payload bytes</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.read_data_bytes">
<code class="sig-name descname">read_data_bytes</code><span class="sig-paren">(</span><em class="sig-param">size</em>, <em class="sig-param">attempt=1</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.read_data_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Read data from the FTDI interface</p>
<p>In UART mode, data contains the serial stream read from the UART
interface.</p>
<p>In MPSSE mode, data contains the sequence of data received and
processed with the MPSEE engine.</p>
<p>Data buffer is rebuilt from chunk-sized blocks received over the USB
bus.</p>
<p>FTDI device always sends internal status bytes, which are stripped
out as not part of the data payload.</p>
<p>Because of the multiple buses, buffers, FIFOs, and MPSSE command
processing, data might not be immediately available on the host
side. The attempt argument can be used to increase the attempt count
to retrieve the expected amount of data, before giving up and
returning all the received data, which may be shorted than the
requested amount.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – the number of bytes to received from the device</p></li>
<li><p><strong>attempt</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – attempt cycle count</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>payload bytes, as bytes</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.read_data_get_chunksize">
<code class="sig-name descname">read_data_get_chunksize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.read_data_get_chunksize" title="Permalink to this definition">¶</a></dt>
<dd><p>Get read buffer chunk size.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the size of the write buffer in bytes</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.read_data_set_chunksize">
<code class="sig-name descname">read_data_set_chunksize</code><span class="sig-paren">(</span><em class="sig-param">chunksize</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.read_data_set_chunksize" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure read buffer chunk size.</p>
<p>This is a low-level configuration option, which is not intended to
be use for a regular usage.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>chunksize</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – the size of the read buffer in bytes</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.read_eeprom">
<code class="sig-name descname">read_eeprom</code><span class="sig-paren">(</span><em class="sig-param">addr=0</em>, <em class="sig-param">length=None</em>, <em class="sig-param">eeprom_size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.read_eeprom" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the EEPROM starting at byte address, addr, and returning
length bytes. Here, addr and length are in bytes but we
access a 16-bit word at a time, so automatically update
addr and length to work with word accesses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>addr</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – byte address that desire to read.</p></li>
<li><p><strong>length</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]) – byte length to read or None</p></li>
<li><p><strong>eeprom_size</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]) – total size in bytes of the eeprom or None</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>eeprom bytes, as an array of bytes</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.read_pins">
<code class="sig-name descname">read_pins</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.read_pins" title="Permalink to this definition">¶</a></dt>
<dd><p>Directly read pin state, circumventing the read buffer.
Useful for bitbang mode.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>bitfield of FTDI interface input GPIO</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.set_baudrate">
<code class="sig-name descname">set_baudrate</code><span class="sig-paren">(</span><em class="sig-param">baudrate</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.set_baudrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the current UART baudrate.</p>
<p>The FTDI device is not able to use an arbitrary baudrate. Its
internal dividors are only able to achieve some baudrates.</p>
<p>PyFtdi attemps to find the closest configurable baudrate and if
the deviation from the requested baudrate is too high, it rejects
the configuration.</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">baudrate</span></code> attribute can be used to retrieve the exact
selected baudrate.</p>
<p><code class="xref py py-const docutils literal notranslate"><span class="pre">BAUDRATE_TOLERANCE</span></code> defines the maximum deviation between
the requested baudrate and the closest FTDI achieveable baudrate,
which matches standard UART clock drift (3%). If the achievable
baudrate is not within limits, baudrate setting is rejected.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>baudrate</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – the new baudrate for the UART.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – if deviation from selected baudrate is too large</p></li>
<li><p><a class="reference internal" href="#pyftdi.ftdi.FtdiError" title="pyftdi.ftdi.FtdiError"><strong>FtdiError</strong></a> – on IO Error</p></li>
</ul>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.set_bitmode">
<code class="sig-name descname">set_bitmode</code><span class="sig-paren">(</span><em class="sig-param">bitmask</em>, <em class="sig-param">mode</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.set_bitmode" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable/disable bitbang modes.</p>
<p>Switch the FTDI interface to bitbang mode.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.set_break">
<code class="sig-name descname">set_break</code><span class="sig-paren">(</span><em class="sig-param">break_</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.set_break" title="Permalink to this definition">¶</a></dt>
<dd><p>Start or stop a break exception event on the serial line</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>break</strong> – either start or stop break event</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.set_dtr">
<code class="sig-name descname">set_dtr</code><span class="sig-paren">(</span><em class="sig-param">state</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.set_dtr" title="Permalink to this definition">¶</a></dt>
<dd><p>Set dtr line</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>state</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – new DTR logical level</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.set_dtr_rts">
<code class="sig-name descname">set_dtr_rts</code><span class="sig-paren">(</span><em class="sig-param">dtr</em>, <em class="sig-param">rts</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.set_dtr_rts" title="Permalink to this definition">¶</a></dt>
<dd><p>Set dtr and rts lines at once</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dtr</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – new DTR logical level</p></li>
<li><p><strong>rts</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – new RTS logical level</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.set_dynamic_latency">
<code class="sig-name descname">set_dynamic_latency</code><span class="sig-paren">(</span><em class="sig-param">lmin</em>, <em class="sig-param">lmax</em>, <em class="sig-param">threshold</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.set_dynamic_latency" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up or disable latency values.</p>
<p>Dynamic latency management is a load balancer to adapt the
responsiveness of FTDI read request vs. the host CPU load.</p>
<p>It is mostly useful in UART mode, so that read bandwidth can be
increased to the maximum achievable throughput, while maintaining
very low host CPU load when no data is received from the UART.</p>
<p>There should be no need to tweak the default values. Use with care.</p>
<p>Minimum latency is limited to 12 or above, at FTDI device starts
losing bytes when latency is too short…</p>
<p>Maximum latency value is 255 ms.</p>
<p>Polling latency is reset to <cite>lmin</cite> each time at least one payload
byte is received from the FTDI device.</p>
<p>It doubles, up to <cite>lmax</cite>, every <cite>threshold</cite> times no payload has
been received from the FTDI device.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lmin</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – minimum latency level (ms)</p></li>
<li><p><strong>lmax</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – maximum latenty level (ms)</p></li>
<li><p><strong>threshold</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – count to reset latency to maximum level</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.set_error_char">
<code class="sig-name descname">set_error_char</code><span class="sig-paren">(</span><em class="sig-param">errorch</em>, <em class="sig-param">enable</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.set_error_char" title="Permalink to this definition">¶</a></dt>
<dd><p>Set error character</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.set_event_char">
<code class="sig-name descname">set_event_char</code><span class="sig-paren">(</span><em class="sig-param">eventch</em>, <em class="sig-param">enable</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.set_event_char" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the special event character</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.set_flowctrl">
<code class="sig-name descname">set_flowctrl</code><span class="sig-paren">(</span><em class="sig-param">flowctrl</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.set_flowctrl" title="Permalink to this definition">¶</a></dt>
<dd><p>Select flowcontrol in UART mode.</p>
<p>Either hardware flow control through RTS/CTS UART lines,
software or no flow control.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>flowctrl</strong> (<em>str</em>) – either ‘hw’ for HW flow control or ‘’ (empty
string) for no flow control.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if the flow control argument is invalid</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>How does RTS/CTS flow control work (from FTDI FAQ):</p>
<p>FTxxx RTS# pin is an output. It should be connected to the CTS#
input pin of the device at the other end of the UART link.</p>
<blockquote>
<div><ul class="simple">
<li><p>If RTS# is logic 0 it is indicating the FTxxx device can
accept more data on the RXD pin.</p></li>
<li><p>If RTS# is logic 1 it is indicating the FTxxx device
cannot accept more data.</p></li>
</ul>
</div></blockquote>
<p>RTS# changes state when the chip buffer reaches its last 32
bytes of space to allow time for the external device to stop
sending data to the FTxxx device.</p>
<p>FTxxx CTS# pin is an input. It should be connected to the RTS#
output pin of the device at the other end of the UART link.</p>
<blockquote>
<div><ul>
<li><p>If CTS# is logic 0 it is indicating the external device can
accept more data, and the FTxxx will transmit on the TXD
pin.</p></li>
<li><p>If CTS# is logic 1 it is indicating the external device
cannot accept more data. the FTxxx will stop transmitting
within 0~3 characters, depending on what is in the buffer.</p>
<p><strong>This potential 3 character overrun does occasionally
present problems.</strong> Customers shoud be made aware the FTxxx
is a USB device and not a “normal” RS232 device as seen on
a PC. As such the device operates on a packet basis as
opposed to a byte basis.</p>
</li>
</ul>
</div></blockquote>
<p>Word to the wise. Not only do RS232 level shifting devices
level shift, but they also invert the signal.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.set_frequency">
<code class="sig-name descname">set_frequency</code><span class="sig-paren">(</span><em class="sig-param">frequency</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.set_frequency" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the current MPSSE bus frequency</p>
<p>The FTDI device is not able to use an arbitrary frequency. Its
internal dividors are only able to achieve some frequencies.</p>
<p>PyFtdi finds and selects the closest configurable frequency.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>frequency</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – the new frequency for the serial interface,
in Hz.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the selected frequency, which may differ from the requested
one, in Hz</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.set_latency_timer">
<code class="sig-name descname">set_latency_timer</code><span class="sig-paren">(</span><em class="sig-param">latency</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.set_latency_timer" title="Permalink to this definition">¶</a></dt>
<dd><p>Set latency timer.</p>
<p>The FTDI chip keeps data in the internal buffer for a specific
amount of time if the buffer is not full yet to decrease
load on the usb bus.</p>
<p>The shorted the latency, the shorted the delay to obtain data and
the higher the host CPU load. Be careful with this option.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>latency</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – latency (unspecified unit)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.set_line_property">
<code class="sig-name descname">set_line_property</code><span class="sig-paren">(</span><em class="sig-param">bits</em>, <em class="sig-param">stopbit</em>, <em class="sig-param">parity</em>, <em class="sig-param">break_=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.set_line_property" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure the (RS232) UART characteristics.</p>
<p>Arguments match the valid subset for FTDI HW of pyserial
definitions.</p>
<p>Bits accepts one of the following values:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">7</span></code> for 7-bit characters</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">8</span></code> for 8-bit characters</p></li>
</ul>
<p>Stopbit accepts one of the following values:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code> for a single bit</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1.5</span></code> for a bit and a half</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2</span></code> for two bits</p></li>
</ul>
<p>Parity accepts one of the following strings:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">N</span></code> for no parity bit</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">O</span></code> for odd parity bit</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">E</span></code> for even parity bit</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">M</span></code> for parity bit always set</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">S</span></code> for parity bit always reset</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bits</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – data bit count</p></li>
<li><p><strong>stopbit</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – stop bit count</p></li>
<li><p><strong>parity</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – parity mode as a single uppercase character</p></li>
<li><p><strong>break</strong> – force break event</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.set_rts">
<code class="sig-name descname">set_rts</code><span class="sig-paren">(</span><em class="sig-param">state</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.set_rts" title="Permalink to this definition">¶</a></dt>
<dd><p>Set rts line</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>state</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – new RTS logical level</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.validate_mpsse">
<code class="sig-name descname">validate_mpsse</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.validate_mpsse" title="Permalink to this definition">¶</a></dt>
<dd><p>Check that the previous MPSSE request has been accepted by the FTDI
device.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyftdi.ftdi.FtdiError" title="pyftdi.ftdi.FtdiError"><strong>FtdiError</strong></a> – if the FTDI device rejected the command.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.write_data">
<code class="sig-name descname">write_data</code><span class="sig-paren">(</span><em class="sig-param">data</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.write_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Write data to the FTDI port.</p>
<p>In UART mode, data contains the serial stream to write to the UART
interface.</p>
<p>In MPSSE mode, data contains the sequence of MPSSE commands and
data.</p>
<p>Data buffer is split into chunk-sized blocks before being sent over
the USB bus.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code>]) – the byte stream to send to the FTDI interface</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>count of written bytes</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.write_data_get_chunksize">
<code class="sig-name descname">write_data_get_chunksize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.write_data_get_chunksize" title="Permalink to this definition">¶</a></dt>
<dd><p>Get write buffer chunk size.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the size of the write buffer in bytes</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.write_data_set_chunksize">
<code class="sig-name descname">write_data_set_chunksize</code><span class="sig-paren">(</span><em class="sig-param">chunksize</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.write_data_set_chunksize" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure write buffer chunk size.</p>
<p>This is a low-level configuration option, which is not intended to
be use for a regular usage.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>chunksize</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – the size of the write buffer in bytes</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.ftdi.Ftdi.write_eeprom">
<code class="sig-name descname">write_eeprom</code><span class="sig-paren">(</span><em class="sig-param">addr</em>, <em class="sig-param">data</em>, <em class="sig-param">eeprom_size=None</em>, <em class="sig-param">dry_run=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.ftdi.Ftdi.write_eeprom" title="Permalink to this definition">¶</a></dt>
<dd><p>Write multiple bytes to the EEPROM starting at byte address,
addr. This function also updates the checksum
automatically.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>You can brick your device with invalid size or content.
Use this function at your own risk, and RTFM.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>addr</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – starting byte address to start writing</p></li>
<li><p><strong>data</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code>]) – data to be written</p></li>
<li><p><strong>eeprom_size</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]) – total size in bytes of the eeprom or None</p></li>
<li><p><strong>dry_run</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – log what should be written, do not actually
change the EEPROM content</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="exceptions">
<h2>Exceptions<a class="headerlink" href="#exceptions" title="Permalink to this headline">¶</a></h2>
<dl class="exception">
<dt id="pyftdi.ftdi.FtdiError">
<em class="property">exception </em><code class="sig-prename descclassname">pyftdi.ftdi.</code><code class="sig-name descname">FtdiError</code><a class="headerlink" href="#pyftdi.ftdi.FtdiError" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class error for all FTDI device</p>
</dd></dl>

<dl class="exception">
<dt id="pyftdi.ftdi.FtdiMpsseError">
<em class="property">exception </em><code class="sig-prename descclassname">pyftdi.ftdi.</code><code class="sig-name descname">FtdiMpsseError</code><a class="headerlink" href="#pyftdi.ftdi.FtdiMpsseError" title="Permalink to this definition">¶</a></dt>
<dd><p>MPSSE mode not supported on FTDI device</p>
</dd></dl>

<dl class="exception">
<dt id="pyftdi.ftdi.FtdiFeatureError">
<em class="property">exception </em><code class="sig-prename descclassname">pyftdi.ftdi.</code><code class="sig-name descname">FtdiFeatureError</code><a class="headerlink" href="#pyftdi.ftdi.FtdiFeatureError" title="Permalink to this definition">¶</a></dt>
<dd><p>Requested feature is not available on FTDI device</p>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="gpio.html" class="btn btn-neutral float-right" title="gpio - GPIO API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="API documentation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Emmanuel Blot &lt;emmanuel.blot@free.fr&gt;

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>