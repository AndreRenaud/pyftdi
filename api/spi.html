

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>spi - SPI API &mdash; PyFtdi  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="serialext - UART API" href="uart.html" />
    <link rel="prev" title="i2c - I2C API" href="i2c.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> PyFtdi
          

          
          </a>

          
            
            
              <div class="version">
                0.44.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../requirements.html">Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../urlscheme.html">URL Scheme</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">API documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html#release"></a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="ftdi.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ftdi</span></code> - FTDI low-level driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="gpio.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gpio</span></code> - GPIO API</a></li>
<li class="toctree-l3"><a class="reference internal" href="i2c.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">i2c</span></code> - I<sup>2</sup>C API</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">spi</span></code> - SPI API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#quickstart">Quickstart</a></li>
<li class="toctree-l4"><a class="reference internal" href="#classes">Classes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#exceptions">Exceptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tests">Tests</a></li>
<li class="toctree-l4"><a class="reference internal" href="#limitations">Limitations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wiring">Wiring</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="uart.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">serialext</span></code> - UART API</a></li>
<li class="toctree-l3"><a class="reference internal" href="usbtools.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">usbtools</span></code> - USB tools</a></li>
<li class="toctree-l3"><a class="reference internal" href="misc.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">misc</span></code> - Miscellaneous helpers</a></li>
<li class="toctree-l3"><a class="reference internal" href="eeprom.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">eeprom</span></code> - EEPROM API</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../pinout.html">FTDI device pinout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eeprom.html">EEPROM management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../troubleshooting.html">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../licenses.html">PyFtdi License</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">PyFtdi</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">API documentation</a> &raquo;</li>
        
      <li><code class="xref py py-mod docutils literal notranslate"><span class="pre">spi</span></code> - SPI API</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api/spi.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-pyftdi.spi">
<span id="spi-spi-api"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">spi</span></code> - SPI API<a class="headerlink" href="#module-pyftdi.spi" title="Permalink to this headline">¶</a></h1>
<div class="section" id="quickstart">
<h2>Quickstart<a class="headerlink" href="#quickstart" title="Permalink to this headline">¶</a></h2>
<p>Example: communication with a SPI data flash (half-duplex example)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Instantiate a SPI controller</span>
<span class="n">spi</span> <span class="o">=</span> <span class="n">SpiController</span><span class="p">()</span>

<span class="c1"># Configure the first interface (IF/1) of the FTDI device as a SPI master</span>
<span class="n">spi</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span><span class="s1">&#39;ftdi://ftdi:2232h/1&#39;</span><span class="p">)</span>

<span class="c1"># Get a port to a SPI slave w/ /CS on A*BUS3 and SPI mode 0 @ 12MHz</span>
<span class="n">slave</span> <span class="o">=</span> <span class="n">spi</span><span class="o">.</span><span class="n">get_port</span><span class="p">(</span><span class="n">cs</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mf">12E6</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Request the JEDEC ID from the SPI slave</span>
<span class="n">jedec_id</span> <span class="o">=</span> <span class="n">slave</span><span class="o">.</span><span class="n">exchange</span><span class="p">([</span><span class="mh">0x9f</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Example: communication with a remote SPI device using full-duplex mode</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Instantiate a SPI controller</span>
<span class="c1"># We need want to use A*BUS4 for /CS, so at least 2 /CS lines should be</span>
<span class="c1"># reserved for SPI, the remaining IO are available as GPIOs.</span>
<span class="n">spi</span> <span class="o">=</span> <span class="n">SpiController</span><span class="p">(</span><span class="n">cs_count</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Configure the first interface (IF/1) of the FTDI device as a SPI master</span>
<span class="n">spi</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span><span class="s1">&#39;ftdi://ftdi:2232h/1&#39;</span><span class="p">)</span>

<span class="c1"># Get a port to a SPI slave w/ /CS on A*BUS4 and SPI mode 2 @ 10MHz</span>
<span class="n">slave</span> <span class="o">=</span> <span class="n">spi</span><span class="o">.</span><span class="n">get_port</span><span class="p">(</span><span class="n">cs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mf">10E6</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Synchronous exchange with the remote SPI slave</span>
<span class="n">write_buf</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x01\x02\x03</span><span class="s1">&#39;</span>
<span class="n">read_buf</span> <span class="o">=</span> <span class="n">slave</span><span class="o">.</span><span class="n">exchange</span><span class="p">(</span><span class="n">write_buf</span><span class="p">,</span> <span class="n">duplex</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Example: communication with a SPI device and an extra GPIO</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Instantiate a SPI controller</span>
<span class="n">spi</span> <span class="o">=</span> <span class="n">SpiController</span><span class="p">()</span>

<span class="c1"># Configure the first interface (IF/1) of the first FTDI device as a</span>
<span class="c1"># SPI master</span>
<span class="n">spi</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span><span class="s1">&#39;ftdi://::/1&#39;</span><span class="p">)</span>

<span class="c1"># Get a SPI port to a SPI slave w/ /CS on A*BUS3 and SPI mode 0 @ 12MHz</span>
<span class="n">slave</span> <span class="o">=</span> <span class="n">spi</span><span class="o">.</span><span class="n">get_port</span><span class="p">(</span><span class="n">cs</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mf">12E6</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Get GPIO port to manage extra pins, use A*BUS4 as GPO, A*BUS4 as GPI</span>
<span class="n">gpio</span> <span class="o">=</span> <span class="n">spi</span><span class="o">.</span><span class="n">get_gpio</span><span class="p">()</span>
<span class="n">gpio</span><span class="o">.</span><span class="n">set_direction</span><span class="p">(</span><span class="mh">0x30</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">)</span>

<span class="c1"># Assert GPO pin</span>
<span class="n">gpio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="mh">0x10</span><span class="p">)</span>
<span class="c1"># Write to SPI slace</span>
<span class="n">slave</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;hello world!&#39;</span><span class="p">)</span>
<span class="c1"># Release GPO pin</span>
<span class="n">gpio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="mh">0x00</span><span class="p">)</span>
<span class="c1"># Test GPI pin</span>
<span class="n">pin</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">gpio</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="o">&amp;</span> <span class="mh">0x20</span><span class="p">)</span>
</pre></div>
</div>
<p>Example: managing non-byte aligned transfers</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Instantiate a SPI controller</span>
<span class="n">spi</span> <span class="o">=</span> <span class="n">SpiController</span><span class="p">()</span>

<span class="c1"># Configure the first interface (IF/1) of the first FTDI device as a</span>
<span class="c1"># SPI master</span>
<span class="n">spi</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span><span class="s1">&#39;ftdi://::/1&#39;</span><span class="p">)</span>

<span class="c1"># Get a SPI port to a SPI slave w/ /CS on A*BUS3</span>
<span class="n">slave</span> <span class="o">=</span> <span class="n">spi</span><span class="o">.</span><span class="n">get_port</span><span class="p">(</span><span class="n">cs</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># write 6 first bits of a byte buffer</span>
<span class="n">slave</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\xff</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">droptail</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># read only 13 bits from a slave (13 clock cycles)</span>
<span class="c1"># only the 5 MSBs of the last byte are valid, 3 LSBs are force to zero</span>
<span class="n">slave</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">droptail</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>See also <a class="reference external" href="https://github.com/eblot/pyspiflash/">pyspiflash</a> module and <code class="docutils literal notranslate"><span class="pre">tests/spi.py</span></code>, which provide more detailed
examples on how to use the SPI API.</p>
</div>
<div class="section" id="classes">
<h2>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyftdi.spi.SpiPort">
<em class="property">class </em><code class="sig-prename descclassname">pyftdi.spi.</code><code class="sig-name descname">SpiPort</code><span class="sig-paren">(</span><em class="sig-param">controller</em>, <em class="sig-param">cs</em>, <em class="sig-param">cs_hold=3</em>, <em class="sig-param">spi_mode=0</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.spi.SpiPort" title="Permalink to this definition">¶</a></dt>
<dd><p>SPI port</p>
<p>An SPI port is never instanciated directly: use
<a class="reference internal" href="#pyftdi.spi.SpiController.get_port" title="pyftdi.spi.SpiController.get_port"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SpiController.get_port()</span></code></a> method to obtain an SPI port.</p>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ctrl</span> <span class="o">=</span> <span class="n">SpiController</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ctrl</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span><span class="s1">&#39;ftdi://ftdi:232h/1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spi</span> <span class="o">=</span> <span class="n">ctrl</span><span class="o">.</span><span class="n">get_port</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spi</span><span class="o">.</span><span class="n">set_frequency</span><span class="p">(</span><span class="mi">1000000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># send 2 bytes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spi</span><span class="o">.</span><span class="n">exchange</span><span class="p">([</span><span class="mh">0x12</span><span class="p">,</span> <span class="mh">0x34</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># send 2 bytes, then receive 2 bytes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">spi</span><span class="o">.</span><span class="n">exchange</span><span class="p">([</span><span class="mh">0x12</span><span class="p">,</span> <span class="mh">0x34</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># send 2 bytes, then receive 4 bytes, manage the transaction</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">spi</span><span class="o">.</span><span class="n">exchange</span><span class="p">([</span><span class="mh">0x12</span><span class="p">,</span> <span class="mh">0x34</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">spi</span><span class="o">.</span><span class="n">exchange</span><span class="p">([],</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyftdi.spi.SpiPort.cs">
<em class="property">property </em><code class="sig-name descname">cs</code><a class="headerlink" href="#pyftdi.spi.SpiPort.cs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the /CS index.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the /CS index (starting from 0)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.spi.SpiPort.exchange">
<code class="sig-name descname">exchange</code><span class="sig-paren">(</span><em class="sig-param">out=b''</em>, <em class="sig-param">readlen=0</em>, <em class="sig-param">start=True</em>, <em class="sig-param">stop=True</em>, <em class="sig-param">duplex=False</em>, <em class="sig-param">droptail=0</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.spi.SpiPort.exchange" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform an exchange or a transaction with the SPI slave</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>out</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]) – data to send to the SPI slave, may be empty to read out
data from the slave with no write.</p></li>
<li><p><strong>readlen</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – count of bytes to read out from the slave,
may be zero to only write to the slave</p></li>
<li><p><strong>start</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – whether to start an SPI transaction, i.e.
activate the /CS line for the slave. Use False to
resume a previously started transaction</p></li>
<li><p><strong>stop</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – whether to desactivete the /CS line for the slave.
Use False if the transaction should complete with a
further call to exchange()</p></li>
<li><p><strong>duplex</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – perform a full-duplex exchange (vs. half-duplex),
i.e. bits are clocked in and out at once.</p></li>
<li><p><strong>droptail</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – ignore up to 7 last bits (for non-byte sized SPI
accesses)</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an array of bytes containing the data read out from the
slave</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.spi.SpiPort.flush">
<code class="sig-name descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.spi.SpiPort.flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Force the flush of the HW FIFOs</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.spi.SpiPort.frequency">
<em class="property">property </em><code class="sig-name descname">frequency</code><a class="headerlink" href="#pyftdi.spi.SpiPort.frequency" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current SPI bus block</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.spi.SpiPort.mode">
<em class="property">property </em><code class="sig-name descname">mode</code><a class="headerlink" href="#pyftdi.spi.SpiPort.mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current SPI mode.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the SPI mode</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.spi.SpiPort.read">
<code class="sig-name descname">read</code><span class="sig-paren">(</span><em class="sig-param">readlen=0</em>, <em class="sig-param">start=True</em>, <em class="sig-param">stop=True</em>, <em class="sig-param">droptail=0</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.spi.SpiPort.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read out bytes from the slave</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>readlen</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – count of bytes to read out from the slave,
may be zero to only write to the slave</p></li>
<li><p><strong>start</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – whether to start an SPI transaction, i.e.
activate the /CS line for the slave. Use False to
resume a previously started transaction</p></li>
<li><p><strong>stop</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – whether to desactivete the /CS line for the slave.
Use False if the transaction should complete with a
further call to exchange()</p></li>
<li><p><strong>droptail</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – ignore up to 7 last bits (for non-byte sized SPI
accesses)</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an array of bytes containing the data read out from the
slave</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.spi.SpiPort.set_frequency">
<code class="sig-name descname">set_frequency</code><span class="sig-paren">(</span><em class="sig-param">frequency</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.spi.SpiPort.set_frequency" title="Permalink to this definition">¶</a></dt>
<dd><p>Change SPI bus frequency</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>frequency</strong> (<em>float</em>) – the new frequency in Hz</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.spi.SpiPort.set_mode">
<code class="sig-name descname">set_mode</code><span class="sig-paren">(</span><em class="sig-param">mode</em>, <em class="sig-param">cs_hold=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.spi.SpiPort.set_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Set or change the SPI mode to communicate with the SPI slave.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mode</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – new SPI mode</p></li>
<li><p><strong>cs_hold</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]) – change the /CS hold duration (or keep using previous
value)</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.spi.SpiPort.write">
<code class="sig-name descname">write</code><span class="sig-paren">(</span><em class="sig-param">out</em>, <em class="sig-param">start=True</em>, <em class="sig-param">stop=True</em>, <em class="sig-param">droptail=0</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.spi.SpiPort.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write bytes to the slave</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>out</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]) – data to send to the SPI slave, may be empty to read out
data from the slave with no write.</p></li>
<li><p><strong>start</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – whether to start an SPI transaction, i.e.
activate the /CS line for the slave. Use False to
resume a previously started transaction</p></li>
<li><p><strong>stop</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – whether to desactivete the /CS line for the slave.
Use False if the transaction should complete with a
further call to exchange()</p></li>
<li><p><strong>droptail</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – ignore up to 7 last bits (for non-byte sized SPI
accesses)</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyftdi.spi.SpiGpioPort">
<em class="property">class </em><code class="sig-prename descclassname">pyftdi.spi.</code><code class="sig-name descname">SpiGpioPort</code><span class="sig-paren">(</span><em class="sig-param">controller</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.spi.SpiGpioPort" title="Permalink to this definition">¶</a></dt>
<dd><p>GPIO port</p>
<p>A SpiGpioPort instance enables to drive GPIOs wich are not reserved for
SPI feature as regular GPIOs.</p>
<p>GPIO are managed as a bitfield. The LSBs are reserved for the SPI
feature, which means that the lowest pin that can be used as a GPIO is
<em>b4</em>:</p>
<ul class="simple">
<li><p><em>b0</em>: SPI SCLK</p></li>
<li><p><em>b1</em>: SPI MOSI</p></li>
<li><p><em>b2</em>: SPI MISO</p></li>
<li><p><em>b3</em>: SPI CS0</p></li>
<li><p><em>b4</em>: SPI CS1 or first GPIO</p></li>
</ul>
<p>If more than one SPI device is used, less GPIO pins are available, see
the cs_count argument of the SpiController constructor.</p>
<p>There is no offset bias in GPIO bit position, <em>i.e.</em> the first available
GPIO can be reached from as <code class="docutils literal notranslate"><span class="pre">0x10</span></code>.</p>
<p>Bitfield size depends on the FTDI device: 4432H series use 8-bit GPIO
ports, while 232H and 2232H series use wide 16-bit ports.</p>
<p>An SpiGpio port is never instanciated directly: use
<a class="reference internal" href="#pyftdi.spi.SpiController.get_gpio" title="pyftdi.spi.SpiController.get_gpio"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SpiController.get_gpio()</span></code></a> method to obtain the GPIO port.</p>
<dl class="method">
<dt id="pyftdi.spi.SpiGpioPort.all_pins">
<em class="property">property </em><code class="sig-name descname">all_pins</code><a class="headerlink" href="#pyftdi.spi.SpiGpioPort.all_pins" title="Permalink to this definition">¶</a></dt>
<dd><p>Report the addressable GPIOs as a bitfield.</p>
<p>A true bit represents a pin which may be used as a GPIO, a false bit
a reserved pin (for SPI support)</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the bitfield of configurable GPIO pins.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.spi.SpiGpioPort.direction">
<em class="property">property </em><code class="sig-name descname">direction</code><a class="headerlink" href="#pyftdi.spi.SpiGpioPort.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide the FTDI GPIO direction.self</p>
<p>A true bit represents an output GPIO, a false bit an input GPIO.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the bitfield of direction.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.spi.SpiGpioPort.pins">
<em class="property">property </em><code class="sig-name descname">pins</code><a class="headerlink" href="#pyftdi.spi.SpiGpioPort.pins" title="Permalink to this definition">¶</a></dt>
<dd><p>Report the configured GPIOs as a bitfield.</p>
<p>A true bit represents a GPIO, a false bit a reserved or not
configured pin.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the bitfield of configured GPIO pins.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.spi.SpiGpioPort.read">
<code class="sig-name descname">read</code><span class="sig-paren">(</span><em class="sig-param">with_output=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.spi.SpiGpioPort.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read GPIO port.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>with_output</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – set to unmask output pins</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the GPIO port pins as a bitfield</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.spi.SpiGpioPort.set_direction">
<code class="sig-name descname">set_direction</code><span class="sig-paren">(</span><em class="sig-param">pins</em>, <em class="sig-param">direction</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.spi.SpiGpioPort.set_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the direction of the GPIO pins.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pins</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – which GPIO pins should be reconfigured</p></li>
<li><p><strong>direction</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – direction bitfield (high level for output)</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.spi.SpiGpioPort.width">
<em class="property">property </em><code class="sig-name descname">width</code><a class="headerlink" href="#pyftdi.spi.SpiGpioPort.width" title="Permalink to this definition">¶</a></dt>
<dd><p>Report the FTDI count of addressable pins.</p>
<p>Note that all pins, including reserved SPI ones, are reported.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the count of IO pins (including SPI ones).</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.spi.SpiGpioPort.write">
<code class="sig-name descname">write</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.spi.SpiGpioPort.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write GPIO port.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>value</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – the GPIO port pins as a bitfield</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyftdi.spi.SpiController">
<em class="property">class </em><code class="sig-prename descclassname">pyftdi.spi.</code><code class="sig-name descname">SpiController</code><span class="sig-paren">(</span><em class="sig-param">cs_count=1</em>, <em class="sig-param">turbo=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.spi.SpiController" title="Permalink to this definition">¶</a></dt>
<dd><p>SPI master.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cs_count</strong> (<em>int</em>) – is the number of /CS lines (one per device to
drive on the SPI bus)</p></li>
<li><p><strong>turbo</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – increase throughput over USB bus, but may not be
supported with some specific slaves</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="pyftdi.spi.SpiController.active_channels">
<em class="property">property </em><code class="sig-name descname">active_channels</code><a class="headerlink" href="#pyftdi.spi.SpiController.active_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide the set of configured slaves /CS.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Set</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Set of /CS, one for each configured slaves</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.spi.SpiController.channels">
<em class="property">property </em><code class="sig-name descname">channels</code><a class="headerlink" href="#pyftdi.spi.SpiController.channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide the maximum count of slaves.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the count of pins reserved to drive the /CS signal</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.spi.SpiController.configure">
<code class="sig-name descname">configure</code><span class="sig-paren">(</span><em class="sig-param">url</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.spi.SpiController.configure" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure the FTDI interface as a SPI master</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>url</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Device</span></code>]) – FTDI URL string, such as <code class="docutils literal notranslate"><span class="pre">ftdi://ftdi:232h/1</span></code></p></li>
<li><p><strong>kwargs</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Mapping</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code>]) – options to configure the SPI bus</p></li>
</ul>
</dd>
</dl>
<p>Accepted options:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">interface</span></code>: when URL is specifed as a USB device, the interface
named argument can be used to select a specific port of the FTDI
device, as an integer starting from 1.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">direction</span></code> a bitfield specifying the FTDI GPIO direction,
where high level defines an output, and low level defines an
input. Only useful to setup default IOs at start up, use
<a class="reference internal" href="#pyftdi.spi.SpiGpioPort" title="pyftdi.spi.SpiGpioPort"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpiGpioPort</span></code></a> to drive GPIOs. Note that pins reserved
for SPI feature take precedence over any this setting.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial</span></code> a bitfield specifying the initial output value. Only
useful to setup default IOs at start up, use
<a class="reference internal" href="#pyftdi.spi.SpiGpioPort" title="pyftdi.spi.SpiGpioPort"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpiGpioPort</span></code></a> to drive GPIOs.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">frequency</span></code> the SPI bus frequency in Hz. Note that each slave
may reconfigure the SPI bus with a specialized
frequency.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cs_count</span></code> count of chip select signals dedicated to select
SPI slave devices, starting from A*BUS3 pin</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">turbo</span></code> whether to enable or disable turbo mode</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">debug</span></code> to increase log verbosity, using MPSSE tracer</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.spi.SpiController.configured">
<em class="property">property </em><code class="sig-name descname">configured</code><a class="headerlink" href="#pyftdi.spi.SpiController.configured" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether the device has been properly configured.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if configured</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.spi.SpiController.direction">
<em class="property">property </em><code class="sig-name descname">direction</code><a class="headerlink" href="#pyftdi.spi.SpiController.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide the FTDI pin direction</p>
<p>A true bit represents an output pin, a false bit an input pin.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the bitfield of direction.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.spi.SpiController.exchange">
<code class="sig-name descname">exchange</code><span class="sig-paren">(</span><em class="sig-param">frequency</em>, <em class="sig-param">out</em>, <em class="sig-param">readlen</em>, <em class="sig-param">cs_prolog=None</em>, <em class="sig-param">cs_epilog=None</em>, <em class="sig-param">cpol=False</em>, <em class="sig-param">cpha=False</em>, <em class="sig-param">duplex=False</em>, <em class="sig-param">droptail=0</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.spi.SpiController.exchange" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform an exchange or a transaction with the SPI slave</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>out</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]) – data to send to the SPI slave, may be empty to read out
data from the slave with no write.</p></li>
<li><p><strong>readlen</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – count of bytes to read out from the slave,
may be zero to only write to the slave,</p></li>
<li><p><strong>cs_prolog</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>]) – the prolog MPSSE command sequence to execute
before the actual exchange.</p></li>
<li><p><strong>cs_epilog</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>]) – the epilog MPSSE command sequence to execute
after the actual exchange.</p></li>
<li><p><strong>cpol</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – SPI clock polarity, derived from the SPI mode</p></li>
<li><p><strong>cpol</strong> – SPI clock phase, derived from the SPI mode</p></li>
<li><p><strong>duplex</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – perform a full-duplex exchange (vs. half-duplex),
i.e. bits are clocked in and out at once or
in a write-then-read manner.</p></li>
<li><p><strong>droptail</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – ignore up to 7 last bits (for non-byte sized SPI
accesses)</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>bytes containing the data read out from the slave, if any</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.spi.SpiController.flush">
<code class="sig-name descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.spi.SpiController.flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Flush the HW FIFOs.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.spi.SpiController.frequency">
<em class="property">property </em><code class="sig-name descname">frequency</code><a class="headerlink" href="#pyftdi.spi.SpiController.frequency" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides the current SPI clock frequency in Hz.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the SPI bus clock frequency</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.spi.SpiController.frequency_max">
<em class="property">property </em><code class="sig-name descname">frequency_max</code><a class="headerlink" href="#pyftdi.spi.SpiController.frequency_max" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides the maximum SPI clock frequency in Hz.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>SPI bus clock frequency</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.spi.SpiController.get_gpio">
<code class="sig-name descname">get_gpio</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.spi.SpiController.get_gpio" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the GPIO port.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyftdi.spi.SpiGpioPort" title="pyftdi.spi.SpiGpioPort"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpiGpioPort</span></code></a></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>GPIO port</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.spi.SpiController.get_port">
<code class="sig-name descname">get_port</code><span class="sig-paren">(</span><em class="sig-param">cs</em>, <em class="sig-param">freq=None</em>, <em class="sig-param">mode=0</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.spi.SpiController.get_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain a SPI port to drive a SPI device selected by Chip Select.</p>
<dl class="field-list simple">
<dt class="field-odd">Note</dt>
<dd class="field-odd"><p>SPI mode 1 and 3 are not officially supported.</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>cs</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – chip select slot, starting from 0</p></li>
<li><p><strong>freq</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – SPI bus frequency for this slave in Hz</p></li>
<li><p><strong>mode</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – SPI mode [0, 1, 2, 3]</p></li>
</ul>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyftdi.spi.SpiPort" title="pyftdi.spi.SpiPort"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpiPort</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.spi.SpiController.gpio_all_pins">
<em class="property">property </em><code class="sig-name descname">gpio_all_pins</code><a class="headerlink" href="#pyftdi.spi.SpiController.gpio_all_pins" title="Permalink to this definition">¶</a></dt>
<dd><p>Report the addressable GPIOs as a bitfield.</p>
<p>A true bit represents a pin which may be used as a GPIO, a false bit
a reserved pin (for SPI support)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the bitfield of configurable GPIO pins.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.spi.SpiController.gpio_pins">
<em class="property">property </em><code class="sig-name descname">gpio_pins</code><a class="headerlink" href="#pyftdi.spi.SpiController.gpio_pins" title="Permalink to this definition">¶</a></dt>
<dd><p>Report the configured GPIOs as a bitfield.</p>
<p>A true bit represents a GPIO, a false bit a reserved or not
configured pin.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the bitfield of configured GPIO pins.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.spi.SpiController.is_inverted_cpha_supported">
<em class="property">property </em><code class="sig-name descname">is_inverted_cpha_supported</code><a class="headerlink" href="#pyftdi.spi.SpiController.is_inverted_cpha_supported" title="Permalink to this definition">¶</a></dt>
<dd><p>Report whether it is possible to supported CPHA=1.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>inverted CPHA supported (with a kludge)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.spi.SpiController.read_gpio">
<code class="sig-name descname">read_gpio</code><span class="sig-paren">(</span><em class="sig-param">with_output=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.spi.SpiController.read_gpio" title="Permalink to this definition">¶</a></dt>
<dd><p>Read GPIO port</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>with_output</strong> – set to unmask output pins</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the GPIO port pins as a bitfield</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.spi.SpiController.set_gpio_direction">
<code class="sig-name descname">set_gpio_direction</code><span class="sig-paren">(</span><em class="sig-param">pins</em>, <em class="sig-param">direction</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.spi.SpiController.set_gpio_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the direction of the GPIO pins</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pins</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – which GPIO pins should be reconfigured</p></li>
<li><p><strong>direction</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – direction bitfield (on for output)</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.spi.SpiController.terminate">
<code class="sig-name descname">terminate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.spi.SpiController.terminate" title="Permalink to this definition">¶</a></dt>
<dd><p>Close the FTDI interface.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.spi.SpiController.width">
<em class="property">property </em><code class="sig-name descname">width</code><a class="headerlink" href="#pyftdi.spi.SpiController.width" title="Permalink to this definition">¶</a></dt>
<dd><p>Report the FTDI count of addressable pins.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the count of IO pins (including SPI ones).</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyftdi.spi.SpiController.write_gpio">
<code class="sig-name descname">write_gpio</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.spi.SpiController.write_gpio" title="Permalink to this definition">¶</a></dt>
<dd><p>Write GPIO port</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>value</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – the GPIO port pins as a bitfield</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="exceptions">
<h2>Exceptions<a class="headerlink" href="#exceptions" title="Permalink to this headline">¶</a></h2>
<dl class="exception">
<dt id="pyftdi.spi.SpiIOError">
<em class="property">exception </em><code class="sig-prename descclassname">pyftdi.spi.</code><code class="sig-name descname">SpiIOError</code><a class="headerlink" href="#pyftdi.spi.SpiIOError" title="Permalink to this definition">¶</a></dt>
<dd><p>SPI I/O error</p>
</dd></dl>

</div>
<div class="section" id="tests">
<h2>Tests<a class="headerlink" href="#tests" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt>SPI sample tests expect:</dt><dd><ul class="simple">
<li><p>MX25L1606E device on /CS 0, SPI mode 0</p></li>
<li><p>ADXL345 device on /CS 1, SPI mode 2</p></li>
<li><p>RFDA2125 device on /CS 2, SPI mode 0</p></li>
</ul>
</dd>
</dl>
<p>Checkout a fresh copy from <a class="reference external" href="https://www.github.com/eblot/pyftdi">PyFtdi</a> github repository.</p>
<p>See <a class="reference internal" href="../pinout.html"><span class="doc">FTDI device pinout</span></a> for FTDI wiring.</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># optional: specify an alternative FTDI device</span>
<span class="nb">export</span> <span class="nv">FTDI_DEVICE</span><span class="o">=</span>ftdi://ftdi:2232h/1
<span class="c1"># optional: increase log level</span>
<span class="nb">export</span> <span class="nv">FTDI_LOGLEVEL</span><span class="o">=</span>DEBUG
<span class="c1"># be sure to connect the appropriate SPI slaves to the FTDI SPI bus and run</span>
<span class="nv">PYTHONPATH</span><span class="o">=</span>. python3 pyftdi/tests/spi.py
</pre></div>
</div>
</div>
<div class="section" id="limitations">
<span id="spi-limitations"></span><h2>Limitations<a class="headerlink" href="#limitations" title="Permalink to this headline">¶</a></h2>
<div class="section" id="spi-modes-1-3">
<h3>SPI Modes 1 &amp; 3<a class="headerlink" href="#spi-modes-1-3" title="Permalink to this headline">¶</a></h3>
<p>FTDI hardware does not support cpha=1 (mode 1 and mode 3). As stated in
Application Node 114:</p>
<blockquote>
<div><p>“<em>It is recommended that designers review the SPI Slave
data sheet to determine the SPI mode implementation. FTDI device can only
support mode 0 and mode 2 due to the limitation of MPSSE engine.</em>”.</p>
</div></blockquote>
<p>Support for mode 1 and mode 3 is implemented with some workarounds, but
generated signals may not be reliable: YMMV. It is only available with -H
series (232H, 2232H, 4232H).</p>
<p>The 3-clock phase mode which has initially be designed to cope with I<sup>2</sup>C
signalling is used to delay the data lines from the clock signals. A direct
consequence of this workaround is that SCLK duty cycle is not longer 50% but
25% (mode 1) or 75% (mode 3). Again, support for mode 1 and mode 3 should be
considered as a kludge, you’ve been warned.</p>
</div>
<div class="section" id="time-sensitive-usage">
<h3>Time-sensitive usage<a class="headerlink" href="#time-sensitive-usage" title="Permalink to this headline">¶</a></h3>
<p>Due to the MPSSE engine limitation, it is not possible to achieve
time-controlled request sequence. In other words, if the SPI slave needs to
receive command sequences at precise instants - for example ADC or DAC
devices - <a class="reference external" href="https://www.github.com/eblot/pyftdi">PyFtdi</a> use is not recommended. This limitation is likely to apply
to any library that relies on FTDI device. The USB bus latency and the lack
of timestamped commands always add jitter and delays, with no easy known
workaround.</p>
</div>
</div>
<div class="section" id="wiring">
<span id="spi-wiring"></span><h2>Wiring<a class="headerlink" href="#wiring" title="Permalink to this headline">¶</a></h2>
<div class="figure align-right" id="id1">
<a class="reference internal image-reference" href="../_images/spi_wiring.png"><img alt="SPI wiring" src="../_images/spi_wiring.png" style="width: 262.0px; height: 269.0px;" /></a>
<p class="caption"><span class="caption-text">Fig.1: FT2232H with two SPI slaves</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">AD0</span></code> should be connected to SCLK</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AD1</span></code> should be connected to MOSI</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AD2</span></code> should be connected to MISO</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AD3</span></code> should be connected to the first slave /CS.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AD4</span></code> should be connected to the second slave /CS, if any</p></li>
<li><p>remaining pins can be freely used as regular GPIOs.</p></li>
</ul>
<p><em>Fig.1</em>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">AD4</span></code> may be used as a regular GPIO if a single SPI slave is used</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AD5</span></code> may be used as another /CS signal for a third slave, in this case
the first available GPIO is <code class="docutils literal notranslate"><span class="pre">AD6</span></code>, etc.</p></li>
</ul>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="uart.html" class="btn btn-neutral float-right" title="serialext - UART API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="i2c.html" class="btn btn-neutral float-left" title="i2c - I2C API" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2010-2020, Emmanuel Blot &lt;emmanuel.blot@free.fr&gt;

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>